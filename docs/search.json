[
  {
    "objectID": "slide/day02.html#社会科学における因果推論の意味",
    "href": "slide/day02.html#社会科学における因果推論の意味",
    "title": "社会科学における因果推論",
    "section": "社会科学における因果推論の意味",
    "text": "社会科学における因果推論の意味\nMorgan and Winship (2014) Counterfactuals and Causal Inference: Methods And Principles For Social Research. Cambridge.\n\nMore has been learned about causal inference in the last few decades than sum total of everything that had been learned about it in all prior recorded history. (Gary King)"
  },
  {
    "objectID": "slide/day02.html#相関から因果へ",
    "href": "slide/day02.html#相関から因果へ",
    "title": "社会科学における因果推論",
    "section": "相関から因果へ",
    "text": "相関から因果へ\n原因 (\\(X\\)) と結果 (\\(Y\\)) の関係: 啓発活動と投票率の関係（架空の例）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\bigcirc\\): 啓発活動が行われる選挙区の投票率は低い（相関関係）\n\\(\\times\\): 啓発活動は投票率を下げる（因果関係）\n\\(\\Rightarrow\\) 統計分析から得られる結果は相関関係のみ\n\n\n\n理論/デザインを用い、観察された相関関係が因果関係であることを説得\n\n因果関係を担保してくれる統計的手法はない。\n\n「これは相関関係でなく因果関係である」と主張するためには、内生性がないことを示す必要がある。"
  },
  {
    "objectID": "slide/day02.html#同時性",
    "href": "slide/day02.html#同時性",
    "title": "社会科学における因果推論",
    "section": "同時性",
    "text": "同時性\nSimultaneity\n\n\n\n\n\n\n\n\n原因と結果の間に双方向の因果関係が存在\n\n例) お酒 (原因; X) とストレス (結果; Y) の関係\n\n酒を飲むとストレスが貯まる\nストレス解消のために酒を飲む\n酒を飲むとストレスが貯まる\nストレス解消のために酒を飲む\n酒を飲むとストレスが貯まる\n…\n\n\\(\\rightarrow\\) 地獄のような無限ループ\n\n\\(\\Rightarrow\\) 酒がストレスに与える影響は?"
  },
  {
    "objectID": "slide/day02.html#見かけ上の相関",
    "href": "slide/day02.html#見かけ上の相関",
    "title": "社会科学における因果推論",
    "section": "見かけ上の相関",
    "text": "見かけ上の相関\nSpurious Correlation、擬似相関\n\nたまたま相関関係がある場合\n\n例) メイン州の離婚率一人当たりマーガリンの消費量"
  },
  {
    "objectID": "slide/day02.html#見かけ上の相関-1",
    "href": "slide/day02.html#見かけ上の相関-1",
    "title": "社会科学における因果推論",
    "section": "見かけ上の相関",
    "text": "見かけ上の相関\nSpurious Correlation、擬似相関\n\n共通の要因からの影響（ビールとアイスクリーム消費量）"
  },
  {
    "objectID": "slide/day02.html#見かけ上の相関-2",
    "href": "slide/day02.html#見かけ上の相関-2",
    "title": "社会科学における因果推論",
    "section": "見かけ上の相関",
    "text": "見かけ上の相関\nSpurious Correlation、擬似相関\n\n共通の要因からの影響（ゲームをやると身長が伸びる説）"
  },
  {
    "objectID": "slide/day02.html#逆の因果",
    "href": "slide/day02.html#逆の因果",
    "title": "社会科学における因果推論",
    "section": "逆の因果",
    "text": "逆の因果\nReverse Causality\n\n例) 心臓移植と生存率の例\n\n\n\n\n\n\n5年後に死亡\n5年後に生存\n\n\n\n\n心臓移植を\n受けた\n10名\n5名\n\n\n\n受けなかった\n5名\n10名\n\n\n\n\n心臓移植を受けたら死亡確率が上がる?\n死亡確率が高い人が心臓移植を受ける?"
  },
  {
    "objectID": "slide/day02.html#逆の因果-1",
    "href": "slide/day02.html#逆の因果-1",
    "title": "社会科学における因果推論",
    "section": "逆の因果",
    "text": "逆の因果\nReverse Causality\n\n「人気だから4文字に略されるのか、4文字に略せるからヒットす るのか、どっちなんでしょうね」"
  },
  {
    "objectID": "slide/day02.html#欠落変数バイアス",
    "href": "slide/day02.html#欠落変数バイアス",
    "title": "社会科学における因果推論",
    "section": "欠落変数バイアス",
    "text": "欠落変数バイアス\nOmitted Variable Bias\n例) 真のモデルが\\(Y = \\beta_0 + \\beta_1 \\cdot X + \\beta_2 \\cdot Z + e\\)の場合\n\n\n\n\n\n\n\n\n\n\n\n\n\nモデルに\\(Z\\)が含まれていなくても\\(\\beta_1\\)の推定値は変化\\(\\times\\)\n\n\\(X\\)と\\(Z\\)は独立（\\(X \\perp Z\\)）\n\\(\\sigma_{X, Z} = 0\\)"
  },
  {
    "objectID": "slide/day02.html#欠落変数バイアス-1",
    "href": "slide/day02.html#欠落変数バイアス-1",
    "title": "社会科学における因果推論",
    "section": "欠落変数バイアス",
    "text": "欠落変数バイアス\nOmitted Variable Bias\n例) 真のモデルが\\(Y = \\beta_0 + \\beta_1 \\cdot X + \\beta_2 \\cdot Z + e\\)の場合\n\n\n\n\n\n\n\n\n\n\n\n\n\nモデルに\\(Z\\)が含まれていない場合、\\(\\beta_1\\)の推定値にバイアス\n\n\\(Z \\rightarrow X\\)の関係が存在\n\\(\\sigma_{X, Z} \\neq 0\\)\n\n\\(\\beta_1\\)の真の値（=不偏推定量）を推定するためには\\(X\\)と\\(Y\\)両方と相関する変数すべてが必要\n\nそもそも、「真の値」とは？\n\\(X\\)と\\(Y\\)両方と相関するすべての変数は特定可能? 測定可能?\n\n\\(\\rightarrow\\) データ分析から得られた結果はあくまでも「分析モデルが想定している世界」のものに過ぎない\n\n定量的手法は反証可能性を高めやすい手法（=科学的な手法になりやすい）であって、科学そのものも、得られた結果が真理であることを保障するものでもない。"
  },
  {
    "objectID": "slide/day02.html#自己選択バイアス",
    "href": "slide/day02.html#自己選択バイアス",
    "title": "社会科学における因果推論",
    "section": "自己選択バイアス",
    "text": "自己選択バイアス\n(Self-)Selection Bias\n\n例1) 職業訓練と期待収入\n\n\n\n\n\n\n3年後の収入\n\n\n\n\n職業訓練を\n受けた\n6349ドル\n\n\n\n受けなかった\n6984ドル\n\n\n\n\n職業訓練を受けたら収入が上がる?\nもともと低収入の人が職業訓練を受けようとする?\n参考) 心臓移植の例も自己選択のバイアスとして解釈可能\n参考) 交絡因子の不在として解釈可能（就労意欲など）"
  },
  {
    "objectID": "slide/day02.html#内生性",
    "href": "slide/day02.html#内生性",
    "title": "社会科学における因果推論",
    "section": "内生性",
    "text": "内生性\nこれまでの多くの例は内生性（endogeneity）の問題\n\n内生性: 説明変数と誤差項間に相関が存在\n\n誤差項と相関のある説明変数: 内生変数（endogenous variable）\n\n内生性がある場合、推定値は一致推定量でも、不偏推定量でもはない\n\nサンプルサイズ（\\(N\\)）をいくら増やしても無駄\n\n内生性の原因\n\n同時性\n欠落変数バイアス\n（体系的な）測定誤差\n自己選択バイアス\n\n最近の教科書はこれはすべてを自己選択バイアスや欠落変数バイアスでまとめる傾向"
  },
  {
    "objectID": "slide/day02.html#単純比較の罠",
    "href": "slide/day02.html#単純比較の罠",
    "title": "社会科学における因果推論",
    "section": "単純比較の罠",
    "text": "単純比較の罠\n啓発活動と投票率の関係（架空の例）\n\n\n\n\n\n\n\n\n\n\n\n\n\n単純比較の手法\n\n平均値の比較、平均値の差の検定（\\(t\\)検定、ANOVA）、単回帰分析など\n啓発ありの投票率 - 啓発なしの投票率 = -10%p\n\n内生性がない場合、「啓発活動は投票率を-10%p下げる」と主張できる。\n本当に、本当に、本当に、内生性はないのか。"
  },
  {
    "objectID": "slide/day02.html#内生性は",
    "href": "slide/day02.html#内生性は",
    "title": "社会科学における因果推論",
    "section": "内生性は?",
    "text": "内生性は?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(Y\\): 投票率\n\\(X\\): 啓発活動の有無\n\\(W\\): 若者の割合\n\\(Z\\): これまでの投票率\n\\(e\\): \\(X\\)と\\(Z\\)以外に、\\(Y\\)に影響を与える要因\n\n\n\n投票率が低い選挙区ほど、啓発活動を行う傾向\n投票率が元々低い選挙区の場合、今回の投票率も低い傾向\n\n\\(\\Rightarrow\\) 自己選択バイアス/欠落変数バイアスの存在\n\n本当に比較すべき対象は…\n\n啓発活動を行わなかったA市 vs. 行ったA市\n啓発活動を行わなかったB市 vs. 行ったB市\nこれらは比較可能か?"
  },
  {
    "objectID": "slide/day02.html#相関から因果へ-1",
    "href": "slide/day02.html#相関から因果へ-1",
    "title": "社会科学における因果推論",
    "section": "相関から因果へ",
    "text": "相関から因果へ\n内生性の除外 \\(\\rightarrow\\) 因果効果の推定"
  },
  {
    "objectID": "slide/day02.html#因果関係の例",
    "href": "slide/day02.html#因果関係の例",
    "title": "社会科学における因果推論",
    "section": "因果関係の例",
    "text": "因果関係の例\nソンさんの講義を履修することで期待年収が上がるか\n\nオバマ君の場合: ソンさんの講義を履修し、年収が5000万円に\n\nソンさんの授業のおかげで富裕層になった（次は社交界進出）\n友達に教えてあげよう\n\n\n講義履修の効果\n\n処置: ソンさんの講義を履修するか否か\n効果: 履修した場合の年収 − 履修しなかった場合の年収"
  },
  {
    "objectID": "slide/day02.html#因果関係の例-1",
    "href": "slide/day02.html#因果関係の例-1",
    "title": "社会科学における因果推論",
    "section": "因果関係の例",
    "text": "因果関係の例\nソンさんの講義を履修することで期待年収が上がるか\n\nオバマ君の場合: ソンさんの講義を履修し、年収が5000万円に\n\nソンさんの授業のおかげで富裕層になった（次は社交界進出）\n友達に教えてあげよう\n\n\n講義履修の効果（ケース1）\n\nオバマ君がソンさんの授業を履修しなくても年収5000万円なら\n\nソンさんの講義の因果効果は0\n\n\n\n\n\n\n履修しなかった場合の年収(A)\n履修した場合の年収(B)\n効果(B-A)\n\n\n\n\nケース1\n5000万\n5000万\n0万"
  },
  {
    "objectID": "slide/day02.html#因果関係の例-2",
    "href": "slide/day02.html#因果関係の例-2",
    "title": "社会科学における因果推論",
    "section": "因果関係の例",
    "text": "因果関係の例\nソンさんの講義を履修することで期待年収が上がるか\n\nオバマ君の場合: ソンさんの講義を履修し、年収が5000万円に\n\nソンさんの授業のおかげで富裕層になった（次は社交界進出）\n友達に教えてあげよう\n\n\n講義履修の効果（ケース2）\n\nオバマ君がソンさんの授業を履修しなかった場合、年収1000万円なら\n\nソンさんの講義の因果効果は4000万円\n一生ソンさんには頭が上がらない\n\n\n\n\n\n\n履修しなかった場合の年収(A)\n履修した場合の年収(B)\n効果(B-A)\n\n\n\n\nケース2\n1000万\n5000万\n4000万"
  },
  {
    "objectID": "slide/day02.html#因果関係の例-3",
    "href": "slide/day02.html#因果関係の例-3",
    "title": "社会科学における因果推論",
    "section": "因果関係の例",
    "text": "因果関係の例\nソンさんの講義を履修することで期待年収が上がるか\n\nオバマ君の場合: ソンさんの講義を履修し、年収が5000万円に\n\nソンさんの授業のおかげで富裕層になった（次は社交界進出）\n友達に教えてあげよう\n\n\n講義履修の効果（ケース3）\n\nオバマ君がソンさんの授業を履修しなかった場合、年収8000万円なら\n\nソンさんの講義の因果効果は-3000万\nソンさんは悪くない\n\n\n\n\n\n\n履修しなかった場合の年収(A)\n履修した場合の年収(B)\n効果(B-A)\n\n\n\n\nケース3\n8000万\n5000万\n-3000万"
  },
  {
    "objectID": "slide/day02.html#因果関係の例-4",
    "href": "slide/day02.html#因果関係の例-4",
    "title": "社会科学における因果推論",
    "section": "因果関係の例",
    "text": "因果関係の例\nソンさんの講義を履修することで期待年収が上がるか\n\nオバマ君の場合: ソンさんの講義を履修し、年収が5000万円に\n\nソンさんの授業のおかげで富裕層になった（次は社交界進出）\n友達に教えてあげよう\n\n\n講義履修の効果\n\nソンさんの講義を履修しなかった場合のオバマ君の年収は…?\n\n個人（オバマ君）における処置効果を推定する際にはこれが不可欠\n\n\n\n\n\n\n履修しなかった場合の年収(A)\n履修した場合の年収(B)\n効果(B-A)\n\n\n\n\nケース1\n5000万\n5000万\n0万\n\n\nケース2\n1000万\n5000万\n4000万\n\n\nケース3\n8000万\n5000万\n-3000万"
  },
  {
    "objectID": "slide/day02.html#潜在的結果枠組み",
    "href": "slide/day02.html#潜在的結果枠組み",
    "title": "社会科学における因果推論",
    "section": "潜在的結果枠組み",
    "text": "潜在的結果枠組み\nNeyman-Rubin-HollandのPotential Outcome Framework\n\n\\(i\\) : 学生ID ( \\(i = 1,2,3,...,N\\) )\n\\(T\\) : 処置\n\n学生 \\(i\\) が謎の薬を飲んだ ( \\(T_i = 1\\) )\n学生 \\(i\\) が謎の薬を飲まなかった ( \\(T_i = 0\\) )\n\n\\(Y_i(T_i = 1)\\) : 学生 \\(i\\) が謎の薬を飲んだ場合の数学成績\n\\(Y_i(T_i = 0)\\) : 学生 \\(i\\) が謎の薬を飲まなかった場合の数学成績\n\\(ITE_i = Y_i(T_i = 1) − Y_i(T_i = 0)\\) : 学生iにおける薬の処置効果\n\nITE: Individual Treatment Effect (個人における処置効果)\n\n= UTE: Unit Treatment Effect\n\n全く同じ個人において薬を飲んだ場合と飲まなかった場合の数学成績の差 = 謎の薬の因果効果"
  },
  {
    "objectID": "slide/day02.html#薬の効果は",
    "href": "slide/day02.html#薬の効果は",
    "title": "社会科学における因果推論",
    "section": "薬の効果は?",
    "text": "薬の効果は?\nITEの平均値は−4であり、個人差はあるものの、全体的に薬は成績に負の影響\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n77\n85\n8\n\n\n2\n1\n49\n59\n10\n\n\n3\n1\n60\n66\n6\n\n\n4\n0\n61\n44\n-17\n\n\n5\n0\n50\n39\n-11\n\n\n6\n0\n75\n55\n-20\n\n\n平均\n\n62\n58\n-4"
  },
  {
    "objectID": "slide/day02.html#因果推論の根本問題-1",
    "href": "slide/day02.html#因果推論の根本問題-1",
    "title": "社会科学における因果推論",
    "section": "因果推論の根本問題",
    "text": "因果推論の根本問題\nしかし、観察できるのは\\(Y_i(T_i = 1)\\)か\\(Y_i(T_i = 0)\\)、片方のみ\n\n\\(Y_i(T_i = 0)\\)は反実仮想（counterfactual）であり、観察不可 (\\(i \\in \\{1,2,3\\}\\))\n\\(Y_i(T_i = 1)\\)も反実仮想(\\(i \\in \\{4,5,6\\}\\))\n\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n?\n85\n?\n\n\n2\n1\n?\n59\n?\n\n\n3\n1\n?\n66\n?\n\n\n4\n0\n61\n?\n?\n\n\n5\n0\n50\n?\n?\n\n\n6\n0\n75\n?\n?\n\n\n平均\n\n62\n70\n8\n\n\n\n\n\n「みんなで薬やろうぜ」って言っていいのか"
  },
  {
    "objectID": "slide/day02.html#世界一受けたいソンさんの授業",
    "href": "slide/day02.html#世界一受けたいソンさんの授業",
    "title": "社会科学における因果推論",
    "section": "世界一受けたいソンさんの授業",
    "text": "世界一受けたいソンさんの授業\n履修者5名と非履修者5名の年収の比較\n\nITEは分からないが、平均値の差分を見ると、+100万円の効果\n\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n?\n700\n?\n\n\n2\n1\n?\n1000\n?\n\n\n3\n1\n?\n550\n?\n\n\n4\n1\n?\n350\n?\n\n\n5\n1\n?\n400\n?\n\n\n6\n0\n400\n?\n?\n\n\n7\n0\n500\n?\n?\n\n\n8\n0\n350\n?\n?\n\n\n9\n0\n750\n?\n?\n\n\n10\n0\n500\n?\n?\n\n\n平均\n\n500\n600\n100"
  },
  {
    "objectID": "slide/day02.html#世界一受けたいソンさんの授業-1",
    "href": "slide/day02.html#世界一受けたいソンさんの授業-1",
    "title": "社会科学における因果推論",
    "section": "世界一受けたいソンさんの授業",
    "text": "世界一受けたいソンさんの授業\n履修者5名と非履修者5名の年収の比較（ケース1）\n\nITEは分からないが、平均値の差分を見ると、+100万円の効果\n80万円の価値があるソンさんの講義、みんなで履修しよう!\n\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n550\n700\n150\n\n\n2\n1\n650\n1000\n350\n\n\n3\n1\n600\n550\n-50\n\n\n4\n1\n300\n350\n50\n\n\n5\n1\n300\n400\n100\n\n\n6\n0\n400\n300\n-100\n\n\n7\n0\n500\n700\n200\n\n\n8\n0\n350\n600\n250\n\n\n9\n0\n750\n700\n-50\n\n\n10\n0\n500\n400\n-100\n\n\n平均\n\n490\n570\n80"
  },
  {
    "objectID": "slide/day02.html#世界一受けたいソンさんの授業-2",
    "href": "slide/day02.html#世界一受けたいソンさんの授業-2",
    "title": "社会科学における因果推論",
    "section": "世界一受けたいソンさんの授業",
    "text": "世界一受けたいソンさんの授業\n履修者5名と非履修者5名の年収の比較（ケース2）\n\nITEは分からないが、平均値の差分を見ると、+100万円の効果\nソンさんは悪くない\n\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n800\n700\n-100\n\n\n2\n1\n650\n1000\n350\n\n\n3\n1\n600\n550\n-50\n\n\n4\n1\n400\n350\n-50\n\n\n5\n1\n350\n400\n50\n\n\n6\n0\n400\n300\n-100\n\n\n7\n0\n500\n500\n0\n\n\n8\n0\n350\n400\n50\n\n\n9\n0\n750\n500\n-250\n\n\n10\n0\n500\n400\n-100\n\n\n平均\n\n530\n510\n-20"
  },
  {
    "objectID": "slide/day02.html#因果推論の根本問題-2",
    "href": "slide/day02.html#因果推論の根本問題-2",
    "title": "社会科学における因果推論",
    "section": "因果推論の根本問題",
    "text": "因果推論の根本問題\n\n\\(Y_i(T_i = 1)\\)か\\(Y_i(T_i = 0)\\)、片方のみしか観察できない状態においてITEから因果効果を推定することは不可能\n\n因果推論の根本問題 (The Fundamental Problem of Causal Inference)\n\n\n\n\n解決方法\n\nもう一回、過去に戻って異なる処置を行う"
  },
  {
    "objectID": "slide/day02.html#因果推論の根本問題-3",
    "href": "slide/day02.html#因果推論の根本問題-3",
    "title": "社会科学における因果推論",
    "section": "因果推論の根本問題",
    "text": "因果推論の根本問題\n\n\\(Y_i(T_i = 1)\\)か\\(Y_i(T_i = 0)\\)、片方のみしか観察できない状態において、ITEから因果効果を推定することは不可能\n\nただし、ドラえもんが存在する世界線を除く\n因果推論の根本問題 (The Fundamental Problem of Causal Inference)\n\n\n\n\n潜在的結果を直接観察する方法\n\nただし、個々人の潜在的結果ではなく、集団における潜在的結果\n平均処置効果 (ATE; Average Treatment Effect)\n\n平均値の差分から平均的な因果効果を推定\nしかし、…\n\n無作為割当の重要性"
  },
  {
    "objectID": "slide/day02.html#平均取るだけでok",
    "href": "slide/day02.html#平均取るだけでok",
    "title": "社会科学における因果推論",
    "section": "平均取るだけでOK?",
    "text": "平均取るだけでOK?\n観察されたデータから差分を計算するだけではATEは推定不可能\n\n\n\n\\(i\\)\n\\(T_i\\)\n\\(Y_i(T_i = 0)\\)\n\\(Y_i(T_i = 1)\\)\n\\(ITE_i\\)\n\n\n\n\n1\n1\n?\n700\n?\n\n\n2\n1\n?\n1000\n?\n\n\n3\n1\n?\n550\n?\n\n\n4\n1\n?\n350\n?\n\n\n5\n1\n?\n400\n?\n\n\n6\n0\n400\n?\n?\n\n\n7\n0\n500\n?\n?\n\n\n8\n0\n350\n?\n?\n\n\n9\n0\n750\n?\n?\n\n\n10\n0\n500\n?\n?\n\n\n平均\n\n500\n600\n100"
  },
  {
    "objectID": "slide/day02.html#信頼できるateの条件",
    "href": "slide/day02.html#信頼できるateの条件",
    "title": "社会科学における因果推論",
    "section": "信頼できるATEの条件",
    "text": "信頼できるATEの条件\nATE推定値の信頼性を損なう敵: 内生性 (しかも、常に存在する)\n例) やる気のある学生だけがソンさんの講義を履修した場合\n\n自己選択バイアス\n\nソンさんの講義は鬼畜すぎるため、やる気満々の学生には役に立つものの、やる気のない学生にとってはむしろ学習意欲が低下\n\n疑似相関\n\nやる気のある学生はいろんな方面で頑張るから、将来年収が高くなる。\n\n測定誤差\n\n履修者の年収はジンバブエ・ドルで測定されている可能性も（これはないか）\n\n\n\n\n内生性は因果推論の敵! どうすれば…?\n\\(\\downarrow\\)\n無作為割当 (Random Assignment)\n\n\n\n\nhttps://www.jaysong.net/kandai-ci"
  },
  {
    "objectID": "slide/day03.html#信頼できるateの条件",
    "href": "slide/day03.html#信頼できるateの条件",
    "title": "社会科学における因果推論",
    "section": "信頼できるATEの条件",
    "text": "信頼できるATEの条件\n内生性の存在 \\(\\rightarrow\\) ATE推定値の信頼性\\(\\downarrow\\)\n例) やる気のある学生だけがソンさんの講義を履修した場合\n\n自己選択バイアス\n\nソンさんの講義は鬼畜すぎるため、やる気満々の学生には役に立つものの、やる気のない学生にとってはむしろ学習意欲が低下\n\n疑似相関\n\nやる気のある学生はいろんな方面で頑張るから、将来年収が高くなる。\n\n測定誤差\n\n履修者の年収はジンバブエ・ドルで測定されている可能性も（これはないか）\n\n\n\n\n内生性は因果推論の敵! どうすれば…?\n\\(\\downarrow\\)\n無作為割当 (Random Assignment)"
  },
  {
    "objectID": "slide/day03.html#無作為割当とは",
    "href": "slide/day03.html#無作為割当とは",
    "title": "社会科学における因果推論",
    "section": "無作為割当とは",
    "text": "無作為割当とは\n無作為割当 (Random Assignment)\n\n処置を受けるかどうかを無作為に割り当てる方法\n\n完全無作為割当: 全ての被験者において、どのグループに属するかの確率が等しい\n\\(Pr(T_i = 1) = Pr(T_j = 1) \\text{ where } i \\neq j\\)\n\\(Pr(T_i = 0) = Pr(T_j = 0) \\text{ where } i \\neq j\\)\n無作為割当の方法は色々\n\n無作為に割り当てると、処置を受けないグループと処置を受けるグループは「集団」として同質なグループになる。\n\n受けないグループ: 統制群 (Control Group)\n受けるグループ: 処置群 (Treatment Group)\n\n一つの集団を一人の個人として扱い、ITEを測定 ⇒ ATE"
  },
  {
    "objectID": "slide/day03.html#無作為割当の力",
    "href": "slide/day03.html#無作為割当の力",
    "title": "社会科学における因果推論",
    "section": "無作為割当の力",
    "text": "無作為割当の力\nコインを投げ、表( \\(H\\) )なら統制群、裏( \\(T\\) )なら処置群に割当\n\nデータ生成Dataの中身\n\n\n\nset.seed(19861008)\nData <- tibble(ID = 1:20,\n               Female = sample(0:1, 20, replace = TRUE, \n                               prob = c(0.4, 0.6)),\n               Age    = round(rnorm(20, 38, 10), 0))\n\nData |>\n   summarise(Female = mean(Female),\n             Age    = mean(Age))\n\n# A tibble: 1 × 2\n  Female   Age\n   <dbl> <dbl>\n1   0.55    38\n\n\n\n\n\n\n\n\n\n\n  \n  \n    \n      ID\n      Female\n      Age\n      \n      ID\n      Female\n      Age\n    \n  \n  \n    1\n1\n31\n\n11\n0\n38\n    2\n1\n41\n\n12\n1\n29\n    3\n0\n31\n\n13\n0\n21\n    4\n1\n46\n\n14\n0\n26\n    5\n1\n37\n\n15\n1\n36\n    6\n1\n37\n\n16\n1\n40\n    7\n0\n30\n\n17\n0\n50\n    8\n1\n46\n\n18\n0\n42\n    9\n1\n56\n\n19\n0\n29\n    10\n0\n47\n\n20\n1\n47"
  },
  {
    "objectID": "slide/day03.html#無作為割当の力-1",
    "href": "slide/day03.html#無作為割当の力-1",
    "title": "社会科学における因果推論",
    "section": "無作為割当の力",
    "text": "無作為割当の力\nコイン投げの結果\n\nコイン投げDataの中身\n\n\n\nset.seed(19861008)\nCoin <- sample(c(\"H\", \"T\"), 20, replace = TRUE)\nCoin\n\n [1] \"H\" \"T\" \"T\" \"T\" \"H\" \"H\" \"H\" \"T\" \"H\" \"H\" \"H\" \"T\" \"H\" \"T\" \"H\" \"T\" \"T\" \"T\" \"H\"\n[20] \"H\"\n\ntable(Coin)\n\nCoin\n H  T \n11  9 \n\nData$Coin <- Coin\n\n\n\n\n\n\n\n\n\n  \n  \n    \n      ID\n      Female\n      Age\n      Coin\n      \n      ID\n      Female\n      Age\n      Coin\n    \n  \n  \n    1\n1\n31\nH\n\n11\n0\n38\nH\n    2\n1\n41\nT\n\n12\n1\n29\nT\n    3\n0\n31\nT\n\n13\n0\n21\nH\n    4\n1\n46\nT\n\n14\n0\n26\nT\n    5\n1\n37\nH\n\n15\n1\n36\nH\n    6\n1\n37\nH\n\n16\n1\n40\nT\n    7\n0\n30\nH\n\n17\n0\n50\nT\n    8\n1\n46\nT\n\n18\n0\n42\nT\n    9\n1\n56\nH\n\n19\n0\n29\nH\n    10\n0\n47\nH\n\n20\n1\n47\nH"
  },
  {
    "objectID": "slide/day03.html#無作為割当の力-2",
    "href": "slide/day03.html#無作為割当の力-2",
    "title": "社会科学における因果推論",
    "section": "無作為割当の力",
    "text": "無作為割当の力\n統制群と処置群が比較的同質的なグループに\n\n統制群（11名）: 女性比率が54.5%、平均年齢が37.2歳\n処置群 (9名): 女性比率が55.6%、平均年齢が39歳\n\n\nData |>\n  group_by(Coin) |>\n  summarise(Female = mean(Female),\n            Age    = mean(Age),\n            N      = n())\n\n# A tibble: 2 × 4\n  Coin  Female   Age     N\n  <chr>  <dbl> <dbl> <int>\n1 H      0.545  37.2    11\n2 T      0.556  39       9"
  },
  {
    "objectID": "slide/day03.html#無作為割当の力-3",
    "href": "slide/day03.html#無作為割当の力-3",
    "title": "社会科学における因果推論",
    "section": "無作為割当の力",
    "text": "無作為割当の力\n集団として処置群と統制群は、母集団とほぼ同質\n\n\\(n \\rightarrow \\infty\\) なら2つのグループはより同質的に（大数の弱法則）\n\n\n\n\n\n女性の割合\n平均年齢\n\n\n\n\n母集団 (\\(n=20\\))\n55.0%\n38.0歳\n\n\n統制群 (\\(n=11\\))\n54.5%\n37.2歳\n\n\n処置群 (\\(n=9\\))\n55.6%\n39.0歳\n\n\n\n\n統制群と処置群、母集団はそれぞれ交換可能 (exchangeable)\n\n処置群に処置を与えること = 母集団全体に処置を与えること\n統制群に処置を与えないこと = 母集団全体に処置を与えないこと\n\n統制群と処置群の比較で集団を一つの単位としたITE (= ATE)が推定可能\n\n処置を与えた母集団 vs. 処置を与えなかった母集団"
  },
  {
    "objectID": "slide/day03.html#無作為割当の力-4",
    "href": "slide/day03.html#無作為割当の力-4",
    "title": "社会科学における因果推論",
    "section": "無作為割当の力",
    "text": "無作為割当の力\n無作為割当は均質な複数のグループを作る手法\n\n講義履修と年収の例だと、無作為割当をすることによって …\n\n各グループにやる気のある学生とない学生が均等に\n\n自己選択バイアス、擬似相関の除去\n\nジンバブエ・ドルで測定される学生も均等に（これはないか）\n\n測定誤差の除去\n\n\n内生性:処置変数（講義の履修）と誤差項（やる気など）間の相関\n\nコイン投げの結果は被験者（学生）の性質と無関係に行われるため、誤差項と相関がない。\n外生変数 (Exogenous variable)\n学生の性質 (X) と処置有無 (T) は独立している ⇒ \\(X \\perp T\\)\n\n\n\n\n無作為割当は内生性を除去する最良の手法"
  },
  {
    "objectID": "slide/day03.html#無作為抽出と無作為割当",
    "href": "slide/day03.html#無作為抽出と無作為割当",
    "title": "社会科学における因果推論",
    "section": "無作為抽出と無作為割当",
    "text": "無作為抽出と無作為割当\n\n無作為抽出によってサンプル（標本）と母集団が交換可能（実はここが難しい）\n無作為割当によって各グループとサンプルに交換可能（=各グループ間で交換可能）\n無作為抽出&無作為割当によって各グループと母集団が交換可能（グループへの刺激=母集団への刺激）"
  },
  {
    "objectID": "slide/day03.html#ランダム化比較試験とは",
    "href": "slide/day03.html#ランダム化比較試験とは",
    "title": "社会科学における因果推論",
    "section": "ランダム化比較試験とは",
    "text": "ランダム化比較試験とは\nRandomized Controlled Trial (RCT)\n\n無作為割当で複数のグループを作り上げた上で、異なる刺激・処置を与え、結果を観察する手法\n\n社会科学でいう「実験」の多くはこれを指す\n因果推論の王道\n\n因果効果をもたらす(と想定される)処置変数が外生的\n\nグループ間における結果変数の差 = 因果効果\n\nデータ生成過程(Data Generating Process; DGP)への直接介入\n\n「真のモデル」が分かる\n\n\n\n\n\n参考）データ生成過程について\n\nKing, Gary. 1989. Unifying Political Methodology, Michigan University Press.（Ch.1-4）\n豊田秀樹. 2022.『統計学入門 II: 尤度によるデータ生成過程の表現』朝倉書店"
  },
  {
    "objectID": "slide/day03.html#データ生成過程への介入",
    "href": "slide/day03.html#データ生成過程への介入",
    "title": "社会科学における因果推論",
    "section": "データ生成過程への介入",
    "text": "データ生成過程への介入\n\\[\n\\text{Income} = \\beta_0 + \\beta_1 \\cdot \\text{Quant} + \\varepsilon\n\\]\n\nIncome: 10年後の年収 (\\(\\in [0, \\infty)\\))\nQuant:ソンさんの講義を履修したか否か (\\(\\in \\{0, 1\\})\\) )\n誤差項(\\(\\varepsilon\\))には「やる気」や「真面目さ」が含まれるため、Quantと相関がある (\\(\\rightarrow\\) 内生性)\n無作為割当で受講有無を決めると、「やる気」や「真面目さ」はQunatと無関係 (独立) になる\n\n例) 受講有無をコイン投げ（W）で決める場合、コインの結果は誤差項（やる気や真面目さ）と独立（ただし、全員がコイン投げの結果に従うと仮定）\n\\(\\Rightarrow\\) 内生性がなくなる!"
  },
  {
    "objectID": "slide/day03.html#実験の方法",
    "href": "slide/day03.html#実験の方法",
    "title": "社会科学における因果推論",
    "section": "実験の方法",
    "text": "実験の方法\nHyde (2015) による分類\n\nフィールド実験: 実際の社会を舞台に行う実験\n\nGerber, Alan S. and Donald P. Green. 2012. Field Experiments, Norton.\n\n実験室実験: 人為的に作られた（=統制された）環境内で行う実験\nサーベイ実験: 世論調査に埋め込む実験\n\nSONG Jaehyun・秦正樹. 2020. 「オンライン・サーベイ実験の方法: 理論編」『理論と方法』35 (1): 92-108.\n秦正樹・SONG Jaehyun. 2020. 「オンライン・サーベイ実験の方法: 実践編」『理論と方法』35 (1): 109-127."
  },
  {
    "objectID": "slide/day03.html#フィールド実験1",
    "href": "slide/day03.html#フィールド実験1",
    "title": "社会科学における因果推論",
    "section": "フィールド実験（1）",
    "text": "フィールド実験（1）\n実際の社会を舞台に行う実験\n\n例1例2\n\n\nIto, Koichiro, Takanori Ida, and Makoto Tanaka. 2018. “Moral Suasion and Economic Incentives: Field Experimental Evidence from Energy Demand,” American Economic Journal: Economic Policy, 10 (1): 240-267.\n\n京都府内の691世帯が対象\n電気メーターを設置し、統制群と処置群1、処置群2に分割\n\n設置のみ (153) / 単純節電要請 (154) / 動機づけ節電要請 (384)\n\n電気使用量の比較\n\n\n\nGerber, Alan S., Donald P. Green, and Christopher W. Larimer. 2010. “An Experiment Testing the Relative Effectiveness of Encouraging Voter Participation by Inducing Feelings of Pride or Shame,” Political Behavior, 32: 409-422.\n\nミシガン州の18万世帯が対象\n4つの処置群にそれぞれ異なる投票を促す内容の葉書を発送\n\n統制群: 99,999世帯 / 処置群1: 20,001世帯 / 処置群2: 20,002世帯 / 処置群3: 20,00 世帯 / 処置群4: 20,000世帯\n\nそれぞれのグループ間の投票率を比較"
  },
  {
    "objectID": "slide/day03.html#フィールド実験2",
    "href": "slide/day03.html#フィールド実験2",
    "title": "社会科学における因果推論",
    "section": "フィールド実験（2）",
    "text": "フィールド実験（2）\n\nメリット\n\n実際の社会と対象にするため、高い外的妥当性\n\n一般的に外的妥当性は実験研究の最大の弱点とも言われる\nただし、全国民ではなく、一部の地域を対象にするケースが多いため、限界もある\n\nIto, Ida and Tanaka (2018) は外的妥当性の確保のために同様の実験を京都以外でも実施 (京都市、横浜市、北九州市、豊田市)\n\n\n\nデメリット\n\n高費用\n\nGerber, Green, and Larimer (2010) は安い方?\n\nアメリカで切手は100円以上の場合が多いため、18万世帯$$100円だけでも1800万円\n葉書もタダじゃない (Amazon.comで100枚12ドル程度)\n\nIto, Ida and Tanaka (2018) は . . .\n\n\n政府や企業などの協力なしでは実施が困難なケースが多い"
  },
  {
    "objectID": "slide/day03.html#実験室実験1",
    "href": "slide/day03.html#実験室実験1",
    "title": "社会科学における因果推論",
    "section": "実験室実験（1）",
    "text": "実験室実験（1）\n人為的に作られた環境内で行う実験\n\n例1例2\n\n\nBlais, André, Simon Labbé-St-Vincent, Laslier Jean-François, Nicolas Sauger, and Karine Van der Straeten. 2011. “Strategic Vote Choice in One-Round and Two-Round Elections: An Experimental Study,” Political Research Quarterly, 64(3): 637–645.\n\n42名 \\(\\times\\) 2グループ\n\nグループ1: 一回投票制4回 \\(\\rightarrow\\) 二回投票制4回\nグループ2: 二回投票制4回 \\(\\rightarrow\\) 一回投票制4回\n\n投票方式による戦略投票 (Strategic Vote) の傾向を比較\n\n\n\nMueller, Pam A. and Daniel M. Oppenheimer. 2014. “The Pen Is Mightier Than the Keyboard: Advantages of Longhand Over Laptop Note Taking,” Psychological Science, 25(6): 1159-1168.\n\n学生を2グループに分割\n\nグループ 1: ノートパソコンでノートテイキング\nグループ 2: ノートとペンでノートテイキング\n\nレクチャーの理解度をグループごとに比較"
  },
  {
    "objectID": "slide/day03.html#実験室実験2",
    "href": "slide/day03.html#実験室実験2",
    "title": "社会科学における因果推論",
    "section": "実験室実験（2）",
    "text": "実験室実験（2）\n\nメリット\n\n環境を自由に操作できる\n被験者の訓練・統制が容易\n\n実験前のルールの説明など\n\n\nデメリット\n\n被験者の属性が偏りやすい \\(\\Rightarrow\\) 低い外的妥当性\n\n主に学生が動員される\nHovland (1959): “College sophomores may not be people.”\n\n\nトレードオフ\n\n一般的に、被験者が少数\n\nSmall \\(N\\) \\(\\leftrightarrow\\) 低コスト(単位を餌にする研究者ならタダでできる)"
  },
  {
    "objectID": "slide/day03.html#サーベイ実験1",
    "href": "slide/day03.html#サーベイ実験1",
    "title": "社会科学における因果推論",
    "section": "サーベイ実験（1）",
    "text": "サーベイ実験（1）\n世論調査に実験を埋め込む方法\n\n例1例2\n\n\nAsaba, Yuki, Kyu S Hahn, Seulgi Jang, Tetsuro Kobayashi, and Atsushi Tago. 2020. “38 seconds above the 38th parallel: how short video clips produced by the US military can promote alignment despite antagonism between Japan and Korea,” International Relations of the Asia-Pacific, 20(2): 253–273.\n\nサーベイの回答者1500名を2グループに分割\n\n統制群: 38秒の日米韓軍事協力に関するPACOM制作の動画を視聴\n処置群: ほぼ同じ長さのPACOM制作の動画を視聴 (日韓の言及はなし)\n\nアメリカに対する感情温度、日韓協力に対する態度を測定\nグループごとに結果を比較\n\n\n\nSong, Jaehyun, Takeshi Iida, Yuriko Takahashi, and Jesús Tovar. 2022 (forthcoming). “Buying Votes across Borders? A List Experiment on Mexican Immigrants in the US,” Canadian Journal of Political Science.\n\n回答者621名を統制群と処置群に割当\n統制群に以下のように質問\n\n\n\n\nNow we are going to show you four activities that some people may experience during the electoral campaign. After you read all four, just answer HOW MANY activities you experienced during the last electoral campaign. (We do NOT want to know which ones, just how many.)\n\nI saw public debates between candidates for presidential elections on TV.\nI saw official websites/blogs of politicians and candidates.\nMy family/friends told me about the election.\nCampaign activists threatened me to vote for a candidate.\n\n\n\n\n\n処置群には「Campaign activists gave any monetary benefits or did a favor to me or my family in Mexico.」を追加\n結果の平均値を比較"
  },
  {
    "objectID": "slide/day03.html#サーベイ実験2",
    "href": "slide/day03.html#サーベイ実験2",
    "title": "社会科学における因果推論",
    "section": "サーベイ実験（2）",
    "text": "サーベイ実験（2）\n\nメリット\n\nコストが低い (数万円で一応実施可能OK)\n大規模の実験が可能（数百人〜数千人）\n機動性が高い\nSUTVA（後述）が満たされやすい\n\nデメリット\n\n実際の環境を再現するのが困難（外的妥当性の問題）\n「行動」を対象とした場合、測定尺度の問題\n不良回答者（satisficer）の存在\n実験のトラブルに対応するのが困難"
  },
  {
    "objectID": "slide/day03.html#rctの例",
    "href": "slide/day03.html#rctの例",
    "title": "社会科学における因果推論",
    "section": "RCTの例",
    "text": "RCTの例\nBertrand, Marianne, and Sendhil Mullainathan. 2004. “Are Emily and Greg More Employable Than Lakisha and Jamal? A Field Experiment on Labor Market Discrimination,” American Economic Review, 94(4): 991-1013.\n\n労働市場における人種差別\n約5000人分の架空の履歴書を求人中の会社へ送る\n\n履歴書の内容 (性別、人種、能力など) は完全無作為\n履歴書に人種は記入できないため、白人っぽい名前 (Emily など)、黒人っぽい名前 (Jamal など) を記入\n\n後は、返事を待つだけ\n\n処置変数: 人種 ( \\(\\in \\{\\text{black}, \\text{white}\\}\\) )\n結果変数: 連絡の有無 ( \\(\\in \\{0, 1\\}\\) )"
  },
  {
    "objectID": "slide/day03.html#内生性の可能性",
    "href": "slide/day03.html#内生性の可能性",
    "title": "社会科学における因果推論",
    "section": "内生性の可能性",
    "text": "内生性の可能性\n\n\n\n\n\n\n\n\n\n\n\n\n誤差項には教育水準、親の所得、居住地などが含まれる\n\n実際に人種と上記の要因には相関あり\n人種 (処置) と誤差項間の相関関係 \\(\\rightarrow\\) 内生性\n\n黒人が採用されなかった場合…\n\n黒人だから? \\(\\leftarrow\\) 人種差別\\(\\bigcirc\\)\n教育水準が低いから \\(\\leftarrow\\) 人種差別\\(\\times\\)\n\n\n\n \\(\\Rightarrow\\) 内生性がある限り、因果効果の識別は困難  \\(\\Rightarrow\\) ケースによって政策的含意が変わる。"
  },
  {
    "objectID": "slide/day03.html#rctの力",
    "href": "slide/day03.html#rctの力",
    "title": "社会科学における因果推論",
    "section": "RCTの力",
    "text": "RCTの力\n\n\n\n\n白人の名前\n黒人の名前\n\n\n\n\nFemale\n76.42%\n77.45%\n\n\nHighQuality\n50.23%\n50.23%\n\n\nCall Rate\n9.65%\n6.45%\n\n\n計 (人)\n2435\n2435\n\n\n\n\n無作為割当の結果、人種と性別・能力の相関がほぼ0に\n\n内生性のない状態\nこの場合、労働市場における人種の因果効果は\n\nATE = 黒人の平均連絡率 − 白人の平均連絡率\n黒人という理由だけで会社から連絡が来る確率が 3.2%p\\(\\downarrow\\)\n-3.2%p: 人種の因果効果 or 処置効果 (treatment effect)"
  },
  {
    "objectID": "slide/day03.html#バランスチェック",
    "href": "slide/day03.html#バランスチェック",
    "title": "社会科学における因果推論",
    "section": "バランスチェック",
    "text": "バランスチェック\n無作為割当が行われているか否かを確認\n\n\n\n\n\n\n\n\n\n\n\n\n標準化差分を使用\n\nStandardized Bias (or Difference)\n\nサンプルサイズの影響\\(\\times\\)\n統計的検定ではない\n\n\\(t\\) 検定、ANOVA、 \\(\\chi^2\\) 検定は\\(\\times\\)\n\nバランスチェックに統計的有意性検定は使わない\n\n{cobalt}、{BalanceR}など"
  },
  {
    "objectID": "slide/day03.html#標準化差分について",
    "href": "slide/day03.html#標準化差分について",
    "title": "社会科学における因果推論",
    "section": "標準化差分について",
    "text": "標準化差分について\n連続変数\n\\[\n\\text{SB}_{T-C} = 100 \\cdot \\frac{\\bar{X}_T - \\bar{X}_C}{\\sqrt{0.5 \\cdot (s_T^2 + s_C^2)}}\n\\]\n二値変数\n\\[\n\\text{SB}_{T-C} = 100 \\cdot \\frac{\\bar{X}_T - \\bar{X}_C}{\\sqrt{0.5 \\cdot (\\bar{X}_T(1-\\bar{X}_T) + \\bar{X}_C(1-\\bar{X}_C))}}\n\\]\n\n\\(\\bar{X}_T\\) : 処置群におけるXの平均値\n\\(s_T^2\\) : 処置群におけるXの分散\n|SB|が小さいほどバランス\n\n明確な基準はないが、3、5、10、25などを使用\n\nグループが3つ以上の場合、それぞれのペアで実行"
  },
  {
    "objectID": "slide/day03.html#因果効果の推定",
    "href": "slide/day03.html#因果効果の推定",
    "title": "社会科学における因果推論",
    "section": "因果効果の推定",
    "text": "因果効果の推定\n\n平均値の差分の検定単回帰分析\n\n\n方法1: グループ間の結果変数の差分の検定 (\\(t\\)検定)\n\n因果効果 (ATE): \\(\\mathbb{E}[\\mbox{Call}|\\mbox{Race = Black}] - \\mathbb{E}[\\mbox{Call}|\\mbox{Race = White}] = -0.032\\)\nATE = 0の帰無仮説の検定\n\n\\(t_{\\text{df} = 4711.7} = −4.117\\); \\(p\\) < 0.001; 95% CI = [−0.047, −0.017]\n\n応答変数の尺度に応じてノンパラメトリック分析\n\n\n\n方法2: 単回帰分析 (線形 or ロジスティックス/プロビット)\n\n\n\n\n\n線形回帰分析（LPM）\n\n\nCovriates\nEst.\nS.E.\n\n\n\n\nIntercept\n0.064\n0.006\n\n\nRace: White\n0.032\n0.008\n\n\n\n\n\n\nロジスティック回帰分析\n\n\nCovriates\nEst.\nS.E.\n\n\n\n\nIntercept\n-2.675\n0.083\n\n\nRace: White\n0.438\n0.107\n\n\n\n\n\n\nプロビット回帰分析\n\n\nCovriates\nEst.\nS.E.\n\n\n\n\nIntercept\n-1.518\n0.039\n\n\nRace: White\n0.217\n0.053\n\n\n\n\n\n\n\n\n\n\n\n\n参考）Freedman, David A. 2008. “Randomization Does Not Justify Logistic Regression,” Statistical Science Statistical Science, 23(2): 237-249.\n\nLogit: 一致推定量\\(\\times\\) & 不偏推定量\\(\\times\\)\nLinear: 一致推定量\\(\\bigcirc\\) & 不偏推定量\\(\\times\\)\n一致性と不偏性の違いについて"
  },
  {
    "objectID": "slide/day03.html#因果効果の推定-重回帰分析は",
    "href": "slide/day03.html#因果効果の推定-重回帰分析は",
    "title": "社会科学における因果推論",
    "section": "因果効果の推定: 重回帰分析は?",
    "text": "因果効果の推定: 重回帰分析は?\n無作為割当のおかげですべての変数が互いに独立\n\n重回帰分析をしても人種のATEは変化しない (OVB がない)\n\n無作為割当の場合、回帰はしてもしなくても良い\n\n現実的に完全にバランスが取れていないため、若干の変化はある\n\n\n\n\nCovriates\nEst.\nS.E.\n\n\n\n\nIntercept\n0.057\n0.007\n\n\nRace: White\n0.032\n0.08\n\n\nFemale\n0.007\n0.009\n\n\nMilitary\n-0.027\n0.014\n\n\nEducation\n-0.002\n0.005\n\n\nHigh Quality\n0.019\n0.008"
  },
  {
    "objectID": "slide/day03.html#因果効果の不均一性",
    "href": "slide/day03.html#因果効果の不均一性",
    "title": "社会科学における因果推論",
    "section": "因果効果の不均一性",
    "text": "因果効果の不均一性\n因果効果が下位グループによって異なる場合\n\n因果効果の不均一性 (heterogeneous treatment effects)\n\n例) 性別によって薬の効果が異なる場合\n薬の効果が男性なら 1、女性なら 2 の場合\n\n男女比が1:1なら、ATEは1.5に\n\n薬の効果が男性なら 4、女性なら-1 の場合\n\n男女比が1:1なら、ATEは1.5だが…\n\n\n方法1: 男女に分けてATEを推定\n方法2: 性別と処置有無の交差項を投入した重回帰分析\n\n\n\n参考) Bryan, Christopher J., Elizabeth Tipton and David S. Yeager. 2021. “Behavioural science is unlikely to change the world without a heterogeneity revolution,” Nature Human Behaviour. 5: 980–989."
  },
  {
    "objectID": "slide/day03.html#因果効果の不均一性intro_data2.csv",
    "href": "slide/day03.html#因果効果の不均一性intro_data2.csv",
    "title": "社会科学における因果推論",
    "section": "因果効果の不均一性（intro_data2.csv）",
    "text": "因果効果の不均一性（intro_data2.csv）\n\ndata2 <- read_csv(\"data/intro_data2.csv\")\n\ndata2\n\n# A tibble: 500 × 4\n      ID Outcome Treatment Female\n   <dbl>   <dbl>     <dbl>  <dbl>\n 1     1  1.09           0      1\n 2     2  0.0281         0      1\n 3     3  1.65           0      0\n 4     4  3.83           1      1\n 5     5  2.65           1      1\n 6     6  1.24           1      1\n 7     7  0.136          1      0\n 8     8  0.507          0      1\n 9     9  2.99           1      1\n10    10  4.34           1      1\n# … with 490 more rows"
  },
  {
    "objectID": "slide/day03.html#因果効果の不均一性-1",
    "href": "slide/day03.html#因果効果の不均一性-1",
    "title": "社会科学における因果推論",
    "section": "因果効果の不均一性",
    "text": "因果効果の不均一性\n方法1: 男女に分けてATEを推定\n\n比較コード1コード2コード3\n\n\n\n\n\n\n統制群\n処置群\nATE\n\\(t\\)\n\\(p\\)\n\n\n\n\n男性のみ\n0.611\n1.561\n0.951\n-7.521\n< 0.001\n\n\n女性のみ\n0.493\n2.480\n1.987\n-15.573\n< 0.001\n\n\n全体\n0.551\n2.057\n1.506\n-15.945\n< 0.001\n\n\n\n\n\n男性のみ\n\nt.test(Outcome ~ Treatment, data = data2, subset = (Female == 0))\n\n\n    Welch Two Sample t-test\n\ndata:  Outcome by Treatment\nt = -7.5211, df = 235.95, p-value = 1.132e-12\nalternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0\n95 percent confidence interval:\n -1.1996845 -0.7016501\nsample estimates:\nmean in group 0 mean in group 1 \n      0.6105137       1.5611810 \n\n\n\n\n女性のみ\n\nt.test(Outcome ~ Treatment, data = data2, subset = (Female == 1))\n\n\n    Welch Two Sample t-test\n\ndata:  Outcome by Treatment\nt = -15.573, df = 259.72, p-value < 2.2e-16\nalternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0\n95 percent confidence interval:\n -2.238053 -1.735599\nsample estimates:\nmean in group 0 mean in group 1 \n      0.4931905       2.4800169 \n\n\n\n\n全体\n\nt.test(Outcome ~ Treatment, data = data2)\n\n\n    Welch Two Sample t-test\n\ndata:  Outcome by Treatment\nt = -15.945, df = 494.24, p-value < 2.2e-16\nalternative hypothesis: true difference in means between group 0 and group 1 is not equal to 0\n95 percent confidence interval:\n -1.692061 -1.320817\nsample estimates:\nmean in group 0 mean in group 1 \n      0.5509135       2.0573524"
  },
  {
    "objectID": "slide/day03.html#因果効果の不均一性-2",
    "href": "slide/day03.html#因果効果の不均一性-2",
    "title": "社会科学における因果推論",
    "section": "因果効果の不均一性",
    "text": "因果効果の不均一性\n方法2: 性別と処置有無の交差項を投入した重回帰分析\n\n\n\nlm(Outcome ~ Treatment * Female, \n   data = data2) |>\n   summary()\n\n\n\n\n\n \n  \n      \n    Model 1 \n  \n \n\n  \n    (Intercept) \n    0.611 (0.091) \n  \n  \n    Treatment \n    0.951 (0.131) \n  \n  \n    Female \n    −0.117 (0.127) \n  \n  \n    Treatment × Female \n    1.036 (0.180) \n  \n  \n    Num.Obs. \n    500 \n  \n  \n    R2 Adj. \n    0.398 \n  \n  \n    F \n    110.905 \n  \n\n\n\n\n\n\n\\[\n\\begin{align}\n\\hat{y} = & \\beta_0 + \\beta_1 \\mbox{Treatment} + \\beta_2 \\mbox{Female} + \\\\\n& \\beta_3 \\mbox{Treatment} \\cdot \\mbox{Female} \\\\\n= & \\beta_0 + (\\beta_1 + \\beta_3 \\mbox{Female}) \\mbox{Treatment} + \\beta_2 \\mbox{Female}.\n\\end{align}\n\\]\n\n処置効果はTreatmentの係数\n\n\\(\\beta_1 + \\beta_3 \\mbox{Female}\\)\n\\(\\Rightarrow\\) 処置効果がFemaleの値にも依存\n\n男性のATE: \\(\\beta_1 + \\beta_3 \\cdot 0 = \\beta_1\\) = 0.951\n女性のATE: \\(\\beta_1 + \\beta_3 \\cdot 1 = \\beta_1 + \\beta_3\\) = 1.987"
  },
  {
    "objectID": "slide/day03.html#因果推論の前提sutva",
    "href": "slide/day03.html#因果推論の前提sutva",
    "title": "社会科学における因果推論",
    "section": "因果推論の前提:SUTVA",
    "text": "因果推論の前提:SUTVA\nStable Unit Treatment Value Assumption\n\n非干渉性処置の無分散性サーベイ実験の場合\n\n\n非干渉性: 他人の処置・統制有無が処置効果に影響を与えないこと\n\n例) AさんITEは\n\n例1) Bさんが統制群の場合は10、処置群の場合は5 \\(\\leftarrow\\)  \n例2) Bさんが統制群の場合も、処置群の場合も、5 \\(\\leftarrow\\)  \n\n\n\n\n\n\n\n例1\n\n\n\nAさんが統制群\nAさんが処置群\n\n\n\n\nBさんが統制群\n0\n10\n\n\nBさんが処置群\n15\n20\n\n\n\n\n\n\n例2\n\n\n\nAさんが統制群\nAさんが処置群\n\n\n\n\nBさんが統制群\n5\n10\n\n\nBさんが処置群\n15\n20\n\n\n\n\n\n\n\n\n\n処置の無分散性: 同じグループに属する対象は同じ処置を受けること\n\n手術の場合: 医者、設備、手順、環境など\n投票参加: 当日、期日前など\n\n\n\n\nサーベイ実験ではSUTVAが満たされやすい。\n\n実験室実験、フィールド実験の場合、「非干渉性」には気をつける。\n例) 隣の人が見てるのとと私が見てるのが違いますが…?"
  },
  {
    "objectID": "slide/day03.html#二重盲検法",
    "href": "slide/day03.html#二重盲検法",
    "title": "社会科学における因果推論",
    "section": "二重盲検法",
    "text": "二重盲検法\n二重盲検法 (Double Blind Test):ある被験者がどのような処置を受けているかについて研究者と被験者両方において不明な状態で実験を行う\n\n二重盲検法を使えば以下の問題点に対処することが可能\n\nプラセボ効果 (placebo effect):偽薬が与えられても、薬だと信じ込む 事によって何らかの効果が生じる\nホーソン効果 (Hawthorne effect):自分が観察されていることを認知さ れることによって何らかの効果が生じる\n観察者効果 (observer/experimenter effect):研究者の期待により被験者へ の対応が異なったり、被験者がその期待に添えるように行動すること"
  },
  {
    "objectID": "slide/day03.html#用意するもの",
    "href": "slide/day03.html#用意するもの",
    "title": "社会科学における因果推論",
    "section": "用意するもの",
    "text": "用意するもの\n\nノートPC\n\nデスクトップを持ち込む自信があるなら、デスクトップでもOK\n\nRの導入\n\n自分のPCにR/RStudioをインストール\nクラウド版のR + RStudioの利用\n分からない場合は至急、宋と相談すること\n\nブラインドタッチのスキル\n\n\n\n\nhttps://www.jaysong.net/kandai-ci"
  },
  {
    "objectID": "slide/day01.html#講義概要-1",
    "href": "slide/day01.html#講義概要-1",
    "title": "社会科学における因果推論",
    "section": "講義概要",
    "text": "講義概要\n\n科目名: 社会科学における因果推論\n講師: 宋財泫 (ソン ジェヒョン)\n所属: 関西大学総合情報学部\n\nE-mail: song [at] kansai-u.ac.jp\nHomepage: https://www.jaysong.net\n\n時間: 月曜日2限（10:40〜12:10）\n教室: TD106"
  },
  {
    "objectID": "slide/day01.html#内容",
    "href": "slide/day01.html#内容",
    "title": "社会科学における因果推論",
    "section": "内容",
    "text": "内容\n\n\n因果推論の考え方\n\n因果推論とは\n内生性（自己選択バイアス）\n因果推論の根本問題\n\n\n因果推論の理論と方法\n\n無作為化比較試験\n回帰分析とその拡張\n\n共変量調整\nマッチング\n差分の差分法\n回帰不連続デザイン\n操作変数法"
  },
  {
    "objectID": "slide/day01.html#実習",
    "href": "slide/day01.html#実習",
    "title": "社会科学における因果推論",
    "section": "実習",
    "text": "実習\n実習はRで行う。4・5回目はRの導入および使い方についても解説（復習レベル）する。\n\n本講義の分析はExcel, SPSS, Stata, Julia, Pythonなどでも可能\n\n\n\n宋のR環境\n\nmacOS 12.5 “Monterey”\nR version 4.2.1 (2022-06-23)\n\nR > 4.1ならOK\n\nRStudio 2022.11.0+105 “Elsbeth Geranium”\nスライド、サポートページ、実習用資料の執筆環境\n\nQuarto 1.1.189\nR package {quarto} 1.2"
  },
  {
    "objectID": "slide/day01.html#前提知識",
    "href": "slide/day01.html#前提知識",
    "title": "社会科学における因果推論",
    "section": "前提知識",
    "text": "前提知識\n第4回講義までに以下の本の内容が理解できていれば問題ない。\n\n浅野正彦・矢内勇生. 2019『Rによる計量政治学』オーム社.\n\n\n\n\n統計学\n\n仮説検定\n統計的有意性検定\n\n\\(p\\)値\\(\\neq\\)帰無仮説が正しい確率\n\n回帰分析\n\n\nR\n\nデータクリーニング、回帰分析、可視化などができるならベスト\n第4・5回にはRの復習を行う\n以下の内容が分かればOK\n\nhttps://www.jaysong.net/micro-book/\n『私たちのR』を読もう！"
  },
  {
    "objectID": "slide/day01.html#サポートページ",
    "href": "slide/day01.html#サポートページ",
    "title": "社会科学における因果推論",
    "section": "サポートページ",
    "text": "サポートページ\n\nhttps://www.jaysong.net/kandai-ci/（ブラウザーの「お気に入り」に登録）"
  },
  {
    "objectID": "slide/day01.html#教科書",
    "href": "slide/day01.html#教科書",
    "title": "社会科学における因果推論",
    "section": "教科書",
    "text": "教科書\n\nなし（サポートページ、およびスライドのみ使用）"
  },
  {
    "objectID": "slide/day01.html#参考書r",
    "href": "slide/day01.html#参考書r",
    "title": "社会科学における因果推論",
    "section": "参考書（R）",
    "text": "参考書（R）\n\n宋財泫・矢内勇生.『私たちのR: ベストプラクティスの探求』（Web-book）\n松村優哉 他. 2021. 『改訂2版 RユーザのためのRStudio[実践]入門』技術評論社\nGarrett Grolemund and Hadley Wickham. 2017. R for Data Science. O’Reilly."
  },
  {
    "objectID": "slide/day01.html#参考書因果推論",
    "href": "slide/day01.html#参考書因果推論",
    "title": "社会科学における因果推論",
    "section": "参考書（因果推論）",
    "text": "参考書（因果推論）\n\n理論\n\n初級: 松林哲也. 2021.『政治学と因果推論』岩波書店.\n初級: Angrist, Joahua D., and Jorn-steffen Pischke. 2014. Mastering ’Metrics: The Path from Cause to Effect. Princeton University Press.\n中級: Angrist, Joahua D., and Jorn-steffen Pischke. 2008. Mostly Harmless Econometrics: An Empiricist’s Companion. Princeton University Press.（『「ほとんど無害」な計量経済学―応用経済学のための実証分析ガイド』）\n\n実装\n\nCunningham, Scott. 2021. Causal Inference: The Mixtape. Yale University Press.\n安井翔太. 2020. 『効果検証入門』技術評論社.\n高橋将宜. 2022. 『統計的因果推論の理論と実装』共立出版.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n:::"
  },
  {
    "objectID": "slide/day01.html#評価-1",
    "href": "slide/day01.html#評価-1",
    "title": "社会科学における因果推論",
    "section": "評価",
    "text": "評価\n期末課題の詳細は学期末（12月頃）アナウンス\n\n平常点: 70%\n\n授業への貢献度\n\n期末課題: 30%\n\n研究構想の発表"
  },
  {
    "objectID": "slide/day01.html#オフィスアワー",
    "href": "slide/day01.html#オフィスアワー",
    "title": "社会科学における因果推論",
    "section": "オフィス・アワー",
    "text": "オフィス・アワー\n宋が研究室に待機し、事前予約なしに相談、質問などが可能な時間\n\n場所：TA227研究室（A棟の2階）\n毎週火曜日3限 (13:00〜14:30)\n上記の時間外は事前予約が必要（メール、対面）\n\n song@kansai-u.ac.jp"
  },
  {
    "objectID": "slide/day01.html#分析環境の準備",
    "href": "slide/day01.html#分析環境の準備",
    "title": "社会科学における因果推論",
    "section": "分析環境の準備",
    "text": "分析環境の準備\n自分のPCにR + RStudioがインストールされている場合\n\nRのバージョンが4.1.2以上であればOK\n\n\n自分のPCにR + RStudioがインストールされていない場合\n\\(\\Rightarrow\\) 少しでも不安があれば宋と相談しよう！\n\n\n方法1: 自分のPCにインストールする。\n\n参考資料: https://yukiyanai.github.io/jp/resources/\n\n\n方法2: クラウド版のR/RStudioを使用する。\n\n参考資料: サポートページ > Rの使い方\n\n\n\n\n\n\nhttps://www.jaysong.net/kandai-ci"
  },
  {
    "objectID": "intro/filesystem.html",
    "href": "intro/filesystem.html",
    "title": "本講義のためのファイル管理術",
    "section": "",
    "text": "PC内に存在するほとんどのファイルは「名前.拡張子」と名付けられている1。名前の拡張子は.で区切られており、名前は英数字と_のみで構成することを推奨する（ファイル名に.が推奨されない理由の一つが名前と拡張子を区分する文字として使われるからだ）。ここで注目したいのはファイルの名前でなく、拡張子のことだ。拡張子とはファイルの特徴を示すものである。たとえば、拡張子が.htmlであれば、ウェブページ形式を意味し、.pngなら図、.pdfなら図・文書、.exeなら実行ファイル、.dmgならディスクイメージを意味する。ファイル名がFigure01.pngならFigure01という名の画像ファイルであることを意味する2。この拡張子によって、パソコンは当該ファイルをどのアプリケーションで開くかを判定する。.exeファイルをダブルクリックするとアプリケーションが立ち上がるし、.pdfファイルをダブルクリックするとPDFビュアーソフトが起動され、中身が表示される。\n　これは拡張子を変えると問題が生じ得ることを意味する。画像ファイルであるFigure01.pngのファイル名を動画ファイル拡張子であるMovie01.mp4に修正しても、そのファイルは動画ファイルにはならない。また、拡張子が.mp4になると、そのファイルを開く際、動画プレイヤーが起動されるが、ファイルの中身は画像ファイルのままなのでエラーが出る。したがって、拡張子は勝手に変えてはならない。たまに課題の結果物としてファイルを提出する際、自分の名前を入れたくてファイル名をXXXX.htmlからXXXX.html_Songへ変更して提出する場合がある。しかし、これは大きな間違いだ。もやはこのファイルはHTMLファイル（.html）でなく、未知のファイル形式（.html_Song）として認識され、ダブルクリックしてもPCはどのアプリケーションで開けば良いかが分からなくなる。ファイル名を修正するならXXXX_Song.htmlのように修正しよう3。\n　Rを用いたデータ分析の場面において頻繁に登場する拡張子は以下の通りである。ファイルの名前は大文字と小文字を区別するが、拡張子の場合、区別されないケースが多い。\n\n\n\n\n\n\n\n\n拡張子\n説明\n備考\n\n\n\n\n.R\nRスクリプトファイル\n\n\n\n.Rproj\nRプロジェクトファイル\n\n\n\n.Rmd\nR Markdownファイル\n\n\n\n.qmd\nQuartoファイル\nRMarkdownに似たようなもの\n\n\n.csv\n表形式ファイル\n業界標準のフォーマット\n\n\n.xlsx or .xls\n表形式ファイル\nExcelで使うフォーマット\n\n\n.dta\n表形式ファイル\nStataで使うフォーマット\n\n\n.sav\n表形式ファイル\nSPSSで使うフォーマット\n\n\n.html\nウェブページファイル\nR Markdown/QuartoをKnitした場合に得られる\n\n\n.png\n画像ファイル\n\n\n\n.pdf\n画像/文書ファイル\n画像にも文書にもなるファイル"
  },
  {
    "objectID": "intro/filesystem.html#ファイルシステム",
    "href": "intro/filesystem.html#ファイルシステム",
    "title": "本講義のためのファイル管理術",
    "section": "2 ファイルシステム",
    "text": "2 ファイルシステム\n　R上でファイルを入出力を行うためにはファイルシステム（file system）を理解する必要がある。\n\n2.1 ファイルの入出力\n　そもそも、ファイルの「入出力」とは何だろうか。これはコンピューターの構造に関わる話なので極めて難しい内容であるが、我々のような消費者（end user）側から見れば、ファイルの入力（input）とは、いわゆるファイルの読み込みを意味し、多くの場合、表形式のデータ（.csv、.xlsxなど）をR上に読み込む作業を意味する。また、ファイルの出力（output）とは、いわゆるファイルの保存。たとえば、作成したスクリプトを.R形式で保存したり、クリーニングしたデータを.csv形式で保存したり、作成した図を.png、.pdf形式で保存したらい、作成した文書を.pdf、.html形式で保存したらいすることがファイルの出力だ。\n\n\n2.2 パスとは\n　ファイルを読み込む場合はファイル名を指定する必要がある。また、ファイルを書き出す場合もファイルに名付ける必要がある。そしてファイル名は名前.拡張子である。ただし、これらのファイルは全て一箇所に集まっているわけではない。もし、全てのファイルが一箇所に集まっていると、必要なファイルを探すのは非常に難しい。通常、PC内には数万のファイルがある。これらのファイルから必要なファイルを探すのは至難の業だろう。したがって、これらのファイルをいくつかの部屋に分けて保管し、この部屋のことをフォルダー（folder）、またはディレクトリ（directory）と呼ぶ（ここでは「フォルダー」と呼ぶとする）。\n　これは我々が住んでいる居住地の「住所」と同じ概念だ。もし、日本に「都道府県」も「市区町村」も「〜丁目、〜番、〜号」という概念がないとしよう。ここでAmazonで魚を購入し、受取先を指定する場合はどうすれば良いだろうか。日本に人が数十人しか住んでいないのであれば、「XXXさんの家」と書くだけで十分かも知れない。しかし、日本には1億人以上の人がある。「ソンさんの家」と書いても届かない。届いたとしても数年、あるいは数十年後に魚の化石の状態で届くかも知れない。そもそも日本に「ソンさん」はこの授業の担当教員以外にもいくらでもいる（ちなみに송（Song; 宋・松）さんも、손（Sohn; 孫）さんも、성（Seong/Sung; 成・星）さんも、선（Sun/Seon; 宣）さんも韓国語では発音が全く別だが、日本ではソンさんになってしまう。）。それぞれの家を何かの区域内に位置づけないとモノが届くまで数年かかってしまう。そこで必要なのが住所だ。「東京都千代田区永田町1丁目7番1号の田中さん」は「東京都」、「千代田区」、「永田町」、「1丁目」、「7番」、「1号」、「田中さん」で構成される。これをファイルシステムに例えると、東京都というフォルダーの中に千代田区というフォルダーがあり、その中には永田町というフォルダー、その中に1丁目といるファルダー、…が存在する。むろん、一つのフォルダーには複数のフォルダーが存在する可能性もある。東京都のフォルダーには千代田区以外にも大田区、中野区、文京区、葛飾区といった複数のフォルダーがあり、千代田区の中にも複数のフォルダーがある。最後の「田中さん」は受け取る人、コンピューターでいるファイル名である。\n　この住所のことをコンピューターではパス（path）と呼ぶ。それぞれのフォルダーは/で区切られる（macOS/Linuxでは/、Windowsでは\\または￥; NIIオンライン分析システムはLinuxベースである）。先ほどの住所の例だと、東京都/千代田区/永田町/1丁目/7番/1号/田中さんとなる（macOS/Linuxの場合）。左に行くほど上位のフォルダーとなり、最後のものはファイル名である。ただし、コンピュターではパスの最初に/を付ける。Windowsなら主にC:\\でスタートし、C:\\東京都\\千代田区\\永田町\\1丁目\\7番\\1号\\田中さんとなる。\n　たとえば、以下のような構造でファイルが保存されているとしよう。拡張子が付いているものはファイル、それ以外はフォルダー、1行目の.は最上位フォルダーである。\n\n\n                      levelName\n1  .                           \n2   ¦--Day01                   \n3   ¦   ¦--Day01.Rproj         \n4   ¦   ¦--Script01.R          \n5   ¦   ¦--Script02.R          \n6   ¦   ¦--Data                \n7   ¦   ¦   ¦--raw_data.csv    \n8   ¦   ¦   °--cleaned_data.csv\n9   ¦   °--Figs                \n10  ¦       ¦--Figure01.png    \n11  ¦       °--Figure02.png    \n12  °--Day02                   \n13      ¦--Day02.Rproj         \n14      ¦--Script01.R          \n15      ¦--Document01.Rmd      \n16      ¦--Document01.html     \n17      ¦--Data                \n18      ¦   °--my_data.csv     \n19      °--Figs                \n20          ¦--Old             \n21          ¦   ¦--Figure01.pdf\n22          ¦   ¦--Figure02.pdf\n23          ¦   °--Figure03.pdf\n24          °--New             \n25              °--Figure01.png\n\n\n　ここでread_csv()関数を使ってDay01フォルダー内のDataフォルダー内のraw_data.csvを読み込む場合はread_csv(\"/Day01/Data/raw_data.csv\")となる。また、ggsave()を用いて、Day02内のFigs内のNew内にFigure02.pngという名で図を保存する場合は、ggsave(filename = \"/Day02/Figs/New/Figure02.png\", ...)と入力する必要がある。しかし、通常、パスを指定する際に、/（WindownならC:\\）から始めることは滅多にない。それは「作業フォルダーはパスで省略可能」だからだ。"
  },
  {
    "objectID": "intro/filesystem.html#rstudioのプロジェクト機能",
    "href": "intro/filesystem.html#rstudioのプロジェクト機能",
    "title": "本講義のためのファイル管理術",
    "section": "3 RStudioのプロジェクト機能",
    "text": "3 RStudioのプロジェクト機能\n　Rでファイルを入出力する時に頭に入れておくべき概念として「作業フォルダー（working folder/working directory）」がある。通常、Rの作業フォルダーはmacOSだと/Users/ユーザー名/、NIIオンライン分析システムだと/home/joyvan/が作業フォルダーだ。そして、パスを指定する場合、作業フォルダーは省略することができる。つまり、現在の作業フォルダーが/home/joyvan/なら\"/home/joyvan/Day01/Data/raw_data.csv\"は\"Day01/Data/raw_data.csv\"に、\"/home/joyvan/Day02/Figs/New/Figure02.png\"は\"Day02/Figs/New/Figure02.png\"に省略される。我々が郵便局で手紙を送る際、住所にわざわざ「日本国」と書かないものと同じである。作業フォルダーはRコンソール上でgetwd()と入力すれば出力される。macOSなら/Users/ユーザー名、NIIオンライン分析システムなら/home/joyvanと出力される。\n\n\n\n\n\n\n最上位フォルダーの話\n\n\n\n　macOSとLinuxに限定した話であるが、最上位フォルダーは/であり、これはシステム上の最上位フォルダーである。個人レベルの最上位フォルダーはmacOSだと/Users/ユーザー名、NIIオンライン分析システムだと/home/joyvanである。そして、この個人レベルの最上位フォルダーは~/と表記することができる。Rコンソールでgetwd()を入力し、以上のように出力されれば個人レベルの最上位フォルダー（~/）が作業フォルダーになっている理解しても良い。ちなみに、WindowsはC:\\がシステム上の最上位フォルダーである。\n\n\n　もし、自分がこれから全ての作業をDay03という名のフォルダー内で完結するとする。つまり、保存するスクリプト（たとえば、Script.R）もDay03に保存し、図（たとえば、FigureA.png）はDay03のFigsフォルダーに、読み込む表形式データ（たとえば、Day03_Data.csv）もDay03の中のDataフォルダーに入れるとする。この場合、それぞれのファイルのパスはDay03/Script.R、Day03/Figs/FigureA.png、Day03/Data/Day03_Data.csvとなる（作業フォルダーが~/であるため、~/は省略可能）。全ての作業が同じフォルダー（とその下位フォルダー）内で行うとしたら、パス名にDay03も不要な気がする。そこで必要なのがRStudioのプロジェクト機能である。\n　RStudioでDay03というプロジェクトを作成すると、Day03フォルダーが自動的に生成され、Day03.Rprojというファイルも生成される。プロジェクトを最上位フォルダーに作成したのであれば、~/Day03/Day03.Rprojファイルが生成されるのである。ここでRStudioのFile > Open ProjectでこのDay03.Rprojファイルを開くとRStudio画面の右上にプロジェクト名が表示され、作業フォルダーがDay03.Rprojが保存されているフォルダー、つまり~/Day03へ変更される（プロジェクトが開かれていな場合は「Project: (None)」と表示される）。実際、NIIオンライン分析システムでXXXという名前のプロジェクトを生成し、そのプロジェクトを開けば作業フォルダーは/home/joyvan/XXX/（=~/XXX/）になる（getwd()で確認可能）。これは大変便利な機能である。なぜなら作業フォルダーまでのパスは全て省略可能だからだ。これまでDay03/Script.R、Day03/Figs/FigureA.png、Day03/Data/Day03_Data.csvだったパスが、それぞれScript.R、Figs/FigureA.png、Data/Day03_Data.csvになる。\n　また、何らかの理由でDay03フォルダーの名前をDay05に変更したとしよう。もし、プロジェクト機能を使っていないのであれば、パスのDay03を全てDay05に変更する必要がある。しかし、プロジェクト機能を使っているのであれば、.Rprojファイルが存在するフォルダーが作業フォルダーになるため、そもそもパスにDay03は存在しない。つまり、修正不要ということだ。ちなみに、プロジェクトを一旦作成したら、そのプロジェクトのフォルダー名や.Rprojファイルの名前は自由に修正しても良いし、フォルダー名と.Rprojファイルの名前が一致しなくても良い。\n　以上の内容をまた住所と郵便の話で例えるとしよう。社内でも郵便物の行き来は頻繁に行われる。とりわけ面積が広く、キャンパスも複数ある大学なら尚更だ。たとえば、「兵庫県神戸市灘区六甲台町2-1 神戸大学 ラーメン研究科」の宋が「兵庫県神戸市灘区六甲台町2-1 神戸大学 さつまいも研究科」の重村に郵便を送る場合、同じ大学であるにも関わらず、住所を全て書くのは面倒なことであろう。ここで神戸大学専用の郵便局を作れば問題は解決される（「学内便」と呼ばれる）。そうすれば差出人は「ラーメン研究科　宋」、受取人は「さつまいも研究科　重村」と書くだけで郵便物は届く。つまり、「兵庫県神戸市灘区六甲台町2-1 神戸大学」は省略できる（同じ市区町村内の引っ越した際、転入・転出届けの住所欄に市区町村名までは省略できるのと同じ）。また、神戸大学がなぜかキャンパスを北海道に移転した場合を考えてみよう。学内便がなければ、郵便物の住所を全て「北海道〜」に変えなければならない。しかし、学内便が存在すればこれまで使ってきた「ラーメン研究科　宋」という表記は有効であろう。\n　このようにRStudioのプロジェクト機能は必須といっても過言ではない。簡単な計算目的として使う場合は問題ないが、何かの分析をする時、授業の実習時、課題時には必ずRStudioの右上が「Project: (None)」になっていないことを確認しよう。\n\n\n\n\n\n\n絶対パスと相対パス\n\n\n\n　これまで紹介したパスの書き方で/（WindowsならC:\\）から始まるパスは、絶対パス（absolute path）またはフルパス（full path）と呼ばれる。これはファイル名を最上位フォルダーを起点に書く方法である。一方、/（WindowsならC:\\）で始まらないパスは相対パス（relative path）呼ばれ、ファイル名を作業フォルダーを起点に書く方法である。"
  },
  {
    "objectID": "intro/filesystem.html#本講義でおすすめするフォルダー構造",
    "href": "intro/filesystem.html#本講義でおすすめするフォルダー構造",
    "title": "本講義のためのファイル管理術",
    "section": "4 本講義でおすすめするフォルダー構造",
    "text": "4 本講義でおすすめするフォルダー構造\n　プロジェクトを作成すれば、プロジェクトフォルダー内に以下のようなフォルダーを作成しよう。\n\n表形式のデータを読み込んだり、保存したりするのであればDataフォルダーをプロジェクトフォルダー内に作成する。\n\n.csv、.xlsx、.sav、.dtaのような表形式ファイルはDataフォルダーに入れる。\nデータを加工し、保存する場合はData/ファイル名.csvなどと指定する。\n\n図を作成し、保存する予定があれば、Figsフォルダーをプロジェクトフォルダー内に作成する。\n\n図を保存する場合、ファイルのパスをFigs/ファイル名.pngやFigs/ファイル名.pdfとする。\n\n\n　よく分からない場合はとりあえずプロジェクトフォルダー内にDataとFigsというフォルダーを作っておこう。ただし、.R、.Rmdなどコードファイルはプロジェクトフォルダーの下位フォルダーに入れず、プロジェクトフォルダーの直に入れよう4。この場合、R Markdown / Quartoで作成された文書（.html、.pdfなど）は.Rmdや.qmdファイルと同じフォルダーに保存される（別途の設定をすれば別フォルダーに保存することも可能だが、そこまではしなくても良い）。"
  },
  {
    "objectID": "intro/filesystem.html#参考",
    "href": "intro/filesystem.html#参考",
    "title": "本講義のためのファイル管理術",
    "section": "5 参考",
    "text": "5 参考\n　以下の内容も合わせて読むことを強く推奨する。\n\n宋財泫・矢内勇生.『私たちのR』の第6.1章: コンピュータの基礎知識"
  },
  {
    "objectID": "intro/file.html",
    "href": "intro/file.html",
    "title": "ファイル管理",
    "section": "",
    "text": "フォルダー/ファイルの管理はJupyterHub内でも、RStudio内でもできるが、ここではRStudio側で管理する方法を紹介する。RStudioを起動し、作業するプロジェクトを開き、Filesペインを確認しよう。RStudioを経由したフォルダー/ファイルの管理は全てFilesペイン上で行われる。"
  },
  {
    "objectID": "intro/file.html#フォルダーの管理",
    "href": "intro/file.html#フォルダーの管理",
    "title": "ファイル管理",
    "section": "1 フォルダーの管理",
    "text": "1 フォルダーの管理\n　講義、または課題ごとのプロジェクトを作ったら、JupyterHubにプロジェクトのフォルダーが生成される。各プロジェクトごとにRスクリプト、Markdownファイル、出力物（図、文書など）が管理できるが、プロジェクト内のファイルが多くなる可能性もある。この場合、プロジェクト・フォルダー内に更に下位フォルダーを作成し、ファイルを管理した方が望ましい。\n\n1.1 フォルダーの作成\n手順1: 現在、Filesペインで表示されているフォルダーがプロジェクトの最上位フォルダーであることを確認する。「Home > プロジェクト名」と表示されていれば問題ない。\n\n\n\n\n\n\n\n\n\n手順2: New Folderをクリックする。\n\n\n\n\n\n\n\n\n\n手順3: 作成するフォルダーの名前を入力する。ここではデータなどを集めておくDataという名のフォルダーを作成する。\n\n\n\n\n\n\n\n\n\n手順4: 正しくフォルダーが作成されているかを確認する。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nフォルダー名の付け方\n\n\n\nフォルダー名にはローマ字、数字のみを使おう。スペースもなるべく使わず、空白を入れたい場合はスペースの代わりにアンダースコア（_）を使おう。\n\n\n\n\n\n\n\n\nフォルダー in フォルダー\n\n\n\nフォルダー内に更にフォルダーを作成することもできる。一つのフォルダー内にファイルが多すぎる場合、更にフォルダー分けして管理した方が効率的だろう。\n\n\n\n\n1.2 フォルダーの削除\n\n\n\n\n\n\nフォルダーの削除は慎重に!\n\n\n\nフォルダーを削除するとフォルダー内のファイルも全て削除される。削除する前には慎重にフォルダー内のファイルを確認しておくこと。\n\n\n手順1: 削除するフォルダーの左にチェックを付け、Deleteをクリックする。\n\n\n\n\n\n\n\n\n\n手順2: Yesをクリックする。"
  },
  {
    "objectID": "intro/file.html#ファイルの管理",
    "href": "intro/file.html#ファイルの管理",
    "title": "ファイル管理",
    "section": "2 ファイルの管理",
    "text": "2 ファイルの管理\n　分析に使用するデータセットを自分のPCにダウンロードしてもそのままNIIオンライン分析システムで使うことはできない。NIIオンライン分析システムで使用するためには、ファイルをアップロードする必要がある。これはデータだけでなく、本講義の課題用ファイルについても同様である。\n\n2.1 ファイルのアップロード\n手順1: ファイルをアップロードしたいフォルダーへ移動する。\n\n下位フォルダーへの移動: フォルダー名をクリックする。\n上位フォルダーへの移動: 「..」をクリックするか、パスが表示されているバーで移動先をクリックする。\n\n手順2: ファイルのアップロード先が正しいかを確認し、Uploadをクリックする。\n\n以下の例はHomework_01プロジェクト・フォルダー内のDataフォルダーがアップロード先である。\n\n\n\n\n\n\n\n\n\n\n手順3: File to upload:でアップロードしたいファイルを選択する。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n複数のファイルをアップロードしたい場合\n\n\n\nRStudio上でファイルは一度の一つしかアップロードできない。複数のファイルを同時にアップロードしたい場合は、この作業を繰り返すか、JupyterHubのホーム画面でアップロードする必要がある。\n\n\n手順4: アップロードするファイルをダブルクリックする。\n\n以下ではPrev_Vote.csvというファイルをアップロードする例である。\n\n\n\n\n\n\n\n\n\n\n手順5: OKをクリックする。\n\n\n\n\n\n\n\n\n\n手順6: 正しくファイルがアップロードされているかを確認する。\n\n\n\n\n\n\n\n\n\n\n\n2.2 ファイルのダウンロード\n　作成した図表をLaTex/Microsoft Word/Powerpoint/Pages/Keynoteなどで使うためには、その図表を自分のPCにダウンロードする必要がある。同様に、課題の出力物をLMSに提出するためにも、出力物を一旦自分のPCにダウンロードしてから提出する必要がある。\n\n\n\n\n\n\n複数ファイルのダウンロード\n\n\n\nアップロードは一度ごとに一つのファイルしかアップロードできないが、ダウンロードは複数のファイルを同時にダウンロードできる。ただし、個別のファイルがダウンロードされるのではなく、一つのファイルととして圧縮（zip形式）されてからダウンロードされる。ダウンロード後はファイルを解凍すること。\n\n\n手順1: ダウンロードするファイル名の左にチェックを付ける。\n\n以下ではMicro_HW01.htmlというファイルをダウンロードする例である。\n\n\n\n\n\n\n\n\n\n\n手順2: More > Export…をクリックする。\n\n\n\n\n\n\n\n\n\n手順3: Downloadをクリックする。"
  },
  {
    "objectID": "intro/install.html",
    "href": "intro/install.html",
    "title": "Rの導入",
    "section": "",
    "text": "本講義の実習はNIIオンライン分析システムの使用を推奨する。（自分 or 大学の）PCにインストールしたR + RStudio、RStuio.cloud、Google Colaboratoryなどの使用を妨げないが、本ページの資料と同じ結果が得られることは保証しない。また、この場合、実習・分析中に起きた不具合についても授業中には対応しない。\n　以下ではNIIオンライン分析システムを用いたRおよびRStudioの導入方法について解説する。\n\n\n\n\n\n\n注意!!!\n\n\n\n初期設定は国立情報学研究所（以下、NII）のサーバーに自分の作業用スペースを借りる作業である。つまり、初期設定を繰り返すことはNIIのサーバー（のスペース）をいくつも借りることとなり、サーバーを圧迫してしまう可能性がある。したがって、初期設定は授業全体を通じて1回のみ実行すること。\n\n\n手順1: OpenIdPアカウントを登録する。\n\n以下のページの手順1〜9を参照すること。\n\nhttps://meatwiki.nii.ac.jp/confluence/pages/viewpage.action?pageId=67620540\n\n登録するメールアドレスは必ずac.jp、go.jpで終わる大学アドレスを使うこと。\n\n手順2: 以下のアドレスにアクセスする（1〜2分所要）。\n\nhttps://binder.cs.rcos.nii.ac.jp/v2/gh/JaehyunSong/binder-kobe/HEAD\n\n手順2: 所属機関に「OpenIdP」を入力・選択し、「選択」をクリックする。\n\n\n\n\n\n\n\n\n\n手順3: OpenIdPのアカウント名とパスワードを入力する。\n\nなにか同意を求める画面が表示される場合、そのまま「同意します」をクリックする。\n\n\n\n\n\n\n\n\n\n\n手順4: 以下のような画面が表示されたらしばらく待つ。\n\n\n\n\n\n\n\n\n\n手順5: 以下のような画面が表示されたら初期設定は完了\n\n\n\n\n\n\n\n\n\n手順6: 初期設定が終わったら、すぐRおよびRStudioが利用可能だが、ここでは一旦右上の「Logout」をクリックし、タブ (or ウィンドウ) を閉じる。"
  },
  {
    "objectID": "intro/install.html#niiオンライン分析システムの起動",
    "href": "intro/install.html#niiオンライン分析システムの起動",
    "title": "Rの導入",
    "section": "2 NIIオンライン分析システムの起動",
    "text": "2 NIIオンライン分析システムの起動\n初期設定が終わったら、今後、以下の手順でNIIオンライン分析システムを起動する。\n手順1: 以下のアドレスにアクセスするか、本ページの右上にある右上の  ボタンをクリックする（右クリックし、新しいタブ or ウィンドウで開くことを推奨する）。\n\nhttps://jupyter.cs.rcos.nii.ac.jp/\n\n手順2: 必要に応じて認証を行う（初期設定の手順2, 3, 4と同じ）。\n手順3: サーバーリストが表示される。URL列のアドレスをクリックする。\n\n参考) 初期設定を1回のみ行ったら1行のみ表示されるため混同することはないが、個人利用などを目的に初期設定を複数回行った場合は2行以上が表示されるだろう。本講義に使うサーバーのURLをクリックすること。\n\n\n\n\n\n\n\n\n\n\n手順4: 以下のような画面が表示されたらNIIオンライン分析システムの起動完了である。この画面を今後、「JupyterHub（ジュピターハブ）のホーム画面」と呼ぶ。"
  },
  {
    "objectID": "intro/install.html#rstudioの起動",
    "href": "intro/install.html#rstudioの起動",
    "title": "Rの導入",
    "section": "3 RStudioの起動",
    "text": "3 RStudioの起動\n手順1: JupyterHubのホーム画面の右上の「New」をクリックし、「RStudio」をクリックする。\n\n\n\n\n\n\n\n\n\n手順2: 以下の画面が表示されたら、RStudioの起動完了である（RStudioの見栄は初期状態の場合、白ベースである）。"
  },
  {
    "objectID": "intro/install.html#rstudioの終了",
    "href": "intro/install.html#rstudioの終了",
    "title": "Rの導入",
    "section": "4 RStudioの終了",
    "text": "4 RStudioの終了\n手順1: RStudio画面右上のオレンジ色のボタンをクリックする。\n\n\n\n\n\n\n\n\n\n手順2: 以下のダイアログが表示されたらタブ、またはウィンドウを閉じる。"
  },
  {
    "objectID": "intro/packages.html",
    "href": "intro/packages.html",
    "title": "パッケージ",
    "section": "",
    "text": "Rには数万以上のパッケージが存在し、Rをインストールするだけでも数十のパッケージが自動的にインストールされる。しかし、データ分析/ハンドリング/可視化の手法は日々発展しており、R内蔵パッケージだけでは対応が難しい (できないわけではない)。したがって、必要に応じて新しいパッケージを導入する必要があるが、パッケージのインストールするにはConsoleペインに以下のように入力する。\ninstall.packages(\"インストールするパッケージ名\")\n　前期の「ミクロ政治データ分析実習」では{tidyverse}パッケージのみ使用する予定である。ただし、本講義ようにセッティングされた環境を導入する場合、{tidyverse}は既に導入済みであるため、以下のコードは実行しなくても良い。"
  },
  {
    "objectID": "intro/packages.html#アップデート",
    "href": "intro/packages.html#アップデート",
    "title": "パッケージ",
    "section": "2 アップデート",
    "text": "2 アップデート\n　特定のパッケージをアップデートする方法はインストールと同じだが、一つ一つのパッケージが全て最新バージョンかどうかを確認するのは大変である。また、久々のアップデートで数十個のパッケージをアップデートする必要があるケースもあろう。この場合、RStudioの内蔵機能を使えば一瞬で更新可能なパッケージのリスト化、インストールができる。\n手順1: PackagesペインのUpdateをクリックする。\n\n\n\n\n\n\n\n\n\n手順2: アップデートしたいパッケージの左にチェックを付けるか、左下のSelect Allをクリックし、右下のInstall Updatesをクリックする。\n\n\n\n\n\n\n\n\n\n　インストール、またはアップデートの際、以下のようなメッセージが出力される場合がある。\n  There are binary versions available but the source versions\n  are later:\n      binary source needs_compilation\nterra 1.5-17 1.5-21              TRUE\nyaml   2.2.2  2.3.4              TRUE\n\nDo you want to install from sources the packages which need compilation? (Yes/no/cancel)\n　この場合、Consoleペイン上でYes、no、cancelのいずれかを入力してReturnキー (Enterキー)を押す必要がある。大文字と小文字は区別すること。どうしても最新のパッケージが欲しい場合はYesを入力すれば良いが、インストールに時間がかかる場合がある。一方、noを入力した場合は、若干古いバージョンがインストールされるが、インストールに必要な時間が短いため、基本的にはnoでも問題ないだろう。cancelを入力した場合はアップデートが全てキャンセルされる。"
  },
  {
    "objectID": "intro/packages.html#教科書",
    "href": "intro/packages.html#教科書",
    "title": "パッケージ",
    "section": "3 教科書",
    "text": "3 教科書\n『私たちのR』の第5章「Rパッケージ」: https://www.jaysong.net/RBook/packages.html"
  },
  {
    "objectID": "intro/project.html",
    "href": "intro/project.html",
    "title": "プロジェクト管理",
    "section": "",
    "text": "手順1: File > New Project…をクリックする。\n\n\n\n\n\n\n\n\n\n手順2: New Directoryをクリックする。\n\n\n\n\n\n\n\n\n\n手順3: New Projectをクリックする。\n\n\n\n\n\n\n\n\n\n手順4: Directory name:にプロジェクト名を入力し、Create Projectをクリックする。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注意: プロジェクト名の付け方\n\n\n\n　プロジェクト名にはローマ字、数字のみを使おう。つまり、日本語、中国語、韓国語、全角文字、スペースはなるべく使わないこと。空白を入れたい場合はスペースの代わりにアンダースコア（_）を使おう。"
  },
  {
    "objectID": "intro/project.html#プロジェクトの開き方",
    "href": "intro/project.html#プロジェクトの開き方",
    "title": "プロジェクト管理",
    "section": "2 プロジェクトの開き方",
    "text": "2 プロジェクトの開き方\n　プロジェクトを作成すれば、自動的に出来たてのプロジェクトが開かれる。しかし、NIIオンライン分析システムから一旦ログアウトし、改めてRStudioを起動する場合、プロジェクトをロードする必要がある。\n手順1: File > Open Project…をクリックする。\n\n\n\n\n\n\n\n\n\n手順2: プロジェクト・フォルダー名をダブルクリックする。\n\n\n\n\n\n\n\n\n\n手順3: .Rprojで終わるファイルをダブルクリックする。\n\n\n\n\n\n\n\n\n\nプロジェクトが正しくロードされている場合、RStudioの右上にプロジェクト名が表示される。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常にプロジェクト機能を使おう!\n\n\n\n　RStudionの右上のプロジェクト名表示が「Project: (None)」になっていることは、現在プロジェクトを開いていないことを意味する。簡単な計算機として使う目的以外（つまり、授業中の実習や課題）は必ずプロジェクト機能を使おう。"
  },
  {
    "objectID": "intro/rstudio.html",
    "href": "intro/rstudio.html",
    "title": "RStudioの設定",
    "section": "",
    "text": "RStudioはそのままでも使えるが、少しカスタマイズするとより使い勝手が良くなる。RStudioのカスタマイズ画面はTools > Global Optionsをクリックすることで表示される。\n以下の設定はNIIオンライン分析システムで使用可能なRStudio最新版 (RStudio Server 2021.09.1+372)の設定であり、宋の設定と同じである。"
  },
  {
    "objectID": "intro/rstudio.html#general",
    "href": "intro/rstudio.html#general",
    "title": "RStudioの設定",
    "section": "1 General",
    "text": "1 General\n\n\n\n\n\n\nRestore .RData into workspace at startupのチェックを消す。\nSave workspace to .RData on exit:をNeverに変更する。\nAlways save history (even when not saving .RData)のチェックを消す。"
  },
  {
    "objectID": "intro/rstudio.html#code",
    "href": "intro/rstudio.html#code",
    "title": "RStudioの設定",
    "section": "2 Code",
    "text": "2 Code\n\n2.1 Editingタブ\n\n\n\n\n\n\nInsert spaces for tabのチェックを付ける。\nTab widthは2、または4を指定する。\nAuto-detect code indentationのチェックを付ける。\nInsert matching parens/quotesのチェックを付ける。\nAuto-indent code after pasteのチェックを付ける。\nVertically align arguments in auto-indentのチェックを付ける。\nAlways save R scripts before sourcingのチェックを付ける。\nCtrl + Return executes:をMulti-line R statementに変更する。\n\n\n\n2.2 Displayタブ\n\n\n\n\n\n\nHighlight selected wordのチェックを付ける。\nHighlight selected lineのチェックを付ける。\nShow line numbersのチェックを付ける。\nShow syntax highlighting in console inputのチェックを付ける。\nHighlight R function callsのチェックを付ける。\nRainbow parenthesesのチェックを付ける。\n\n\n\n2.3 Savingタブ\n\n\n\n\n\n\nDefault text encoding:のChangeをクリックし、UTF-8を選択する。\n\n\n\n2.4 Completionタブ\n\n\n\n\n\n\nShow code completion:をAutomaticallyに変更する。\nAllow automatic completions in consoleのチェックを付ける。\nInsert parentheses after function completionsのチェックを付ける。\nShow help tooltip after function completionsのチェックを付ける。\nInsert spaces around equals for argument completionsのチェックを付ける。\nUse tab for autocompletionのチェックを付ける。"
  },
  {
    "objectID": "intro/rstudio.html#console",
    "href": "intro/rstudio.html#console",
    "title": "RStudioの設定",
    "section": "3 Console",
    "text": "3 Console\n\n\n\n\n\n\nShow syntax highlighting in console inputのチェックを付ける。"
  },
  {
    "objectID": "intro/rstudio.html#appearance",
    "href": "intro/rstudio.html#appearance",
    "title": "RStudioの設定",
    "section": "4 Appearance",
    "text": "4 Appearance\n\n\n\n\n\n\n自分の好みのものを選択する。ただし、小さすぎる文字サイズ (font size) は推奨しない。目に優しくないだけでなく、誤字脱字が見つけにくくなる。"
  },
  {
    "objectID": "intro/rstudio.html#pane-layout",
    "href": "intro/rstudio.html#pane-layout",
    "title": "RStudioの設定",
    "section": "5 Pane Layout",
    "text": "5 Pane Layout\n\n\n\n\n\n\n左上: Source\n右上: Console\n左下: 全てチェックを消す。\n左下: 全てチェックを付ける。"
  },
  {
    "objectID": "intro/rstudio.html#r-markdown",
    "href": "intro/rstudio.html#r-markdown",
    "title": "RStudioの設定",
    "section": "6 R Markdown",
    "text": "6 R Markdown\n\n\n\n\n\n\nShow output preview in:をViewer Paneに変更する。\nShow output inline for all R Markdown documentsのチェックを消す。\n\n設定が終わったら右下のOK、またはApplyをクリックする。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Causal Inference in Social Science@Kandai",
    "section": "",
    "text": "アイコン説明\n\n\n\n\n：NIIオンライン分析システムの起動\n\n右クリックし、新しいタブ（or ウィンドウ）で開いてください。\n初期設定が必要です。初期設定の方法はRの使い方 > Rの導入を参照してください。\n\n：Rの教科書（『私たちのR』）\n：本ウェブサイト内の検索\n\n\n\n\n\n\n\n\n\nページ情報\n\n\n\n\n最終更新日: 2022年09月16日\n開発環境\n\nmacOS 12.5.1 “Monterey”\nFirefox 104.0.2\nR version 4.2.1 (2022-06-23)\nRStudio 2022.07.1+554 “Elsbeth Geranium”\nQuarto 1.1.189\nR package {quarto} 1.2\n\n本サポートページのレポジトリ"
  },
  {
    "objectID": "syllabus.html",
    "href": "syllabus.html",
    "title": "本講義について",
    "section": "",
    "text": "科目名: 社会科学における因果推論\n講師: 宋財泫 (ソン ジェヒョン)\n所属: 関西大学総合情報学部\n\nE-mail: song [at] kansai-u.ac.jp\nHomepage: https://www.jaysong.net\n\n時間: 月曜日2限（10:40〜12:10）\n教室: TD106"
  },
  {
    "objectID": "syllabus.html#授業の内容",
    "href": "syllabus.html#授業の内容",
    "title": "本講義について",
    "section": "授業の内容",
    "text": "授業の内容\n　本講義は、近年社会科学において関心が高まっている「因果推論」を行うための諸手段を理解・習得することを目的とする。最初に、最良の因果推論とも称される RCT(ランダム化比較試験)を説明し、RCTが不可能な際の手法としてマッチング、回帰不連続デザイン、差分の差分法、操作変数法などを紹介する。"
  },
  {
    "objectID": "syllabus.html#評価",
    "href": "syllabus.html#評価",
    "title": "本講義について",
    "section": "評価",
    "text": "評価\n\n平常点: 70%\n\n授業への参加度、質問など\n\n期末課題: 30%\n\n第16回の研究構想の発表"
  },
  {
    "objectID": "syllabus.html#履修上の注意",
    "href": "syllabus.html#履修上の注意",
    "title": "本講義について",
    "section": "履修上の注意",
    "text": "履修上の注意\n　統計学に関する基礎知識が必要である。目安は母平均の差の検定、および線形回帰分析が理解でき、統計ソフトウェアで実行・解釈が可能なレベルである。\n　本講義における共通言語はRである。Rの使い方に関しては既にインターネット上に膨大な情報がある。宋と矢内勇生(高知工科大学)が執筆中の以下の資料(無料で閲覧可能)を参照することも1つの選択肢である。\n\n宋財泫・矢内勇生. 『私たちの R: ベストプラクティスの探究』(web-book)\n\nRの導入方法は講義中、宋が解説する。\n\n\n　統計学および定量的分析、Rの使い方については以下の書籍を講義開始日までに読んで おくことを強く推奨する。\n\n浅野正彦・矢内勇生. 2019『Rによる計量政治学』オーム社.\n\n　R スクリプト作成の際、{tidyverse} というパッケージ群を積極的に活用する。この パッケージには {dplyr}、{ggplot2} などのパッケージが含まれている。各パッケージの 使い方を習得するには以下の教材を推奨する。\n\nWickham, Hadley and Grolemund, Garrett. 2017. R for Data Science: Import, Tidy, Transform, Visualize, and Model Data, O’Reilly. (邦訳あり/原著はインターネットから無料で閲覧可)\n松村優哉・湯谷啓明・紀ノ定保礼・前田和寛 . 2021. 『改訂2版 Rユーザのための RStudio[実践] 入門—tidyverseによるモダンな分析フローの世界—』技術評論社."
  },
  {
    "objectID": "syllabus.html#教科書参考書",
    "href": "syllabus.html#教科書参考書",
    "title": "本講義について",
    "section": "教科書・参考書",
    "text": "教科書・参考書\n以下は本書の内容を(一部)カバーする書籍の目録である。必ずしも購入する必要はないが、予習・復習において適宜参照することを推奨する。\n\n因果推論の理論と実例\n\nAngrist, Joahua D., and Jorn-steffen Pischke. 2008. Mostly Harmless Econometrics: An Empiricist’s Companion. Princeton University Press.\n\n『「ほとんど無害」な計量経済学―応用経済学のための実証分析ガイド』 (翻訳はかなり有害)\n\nAngrist, Joahua D., and Jorn-steffen Pischke. 2014. Mastering ’Metrics: The Path from Cause to Effect. Princeton University Press.\n森田果. 2014.『実証分析入門—データから「因果関係」を読み解く作法』日本評論社.\n中室牧子・津川友介. 2017.『「原因と結果」の経済学—データから真実を見抜く思考法』ダイヤモンド社.\n伊藤公一郎. 2017.『データ分析の力—因果関係に迫る思考法』光文社新書.\n松林哲也. 2021.『政治学と因果推論』岩波書店.\n\n理論+R\n\n星野匡郎・田中久稔. 2016.『Rによる実証分析—回帰分析から因果分析へ—』オーム社.\n安井翔太. 2020. 『効果検証入門—正しい比較のための因果推論/計量経済学の基礎』技術評論社.\nCunningham, Scott. 2021. Causal Inference: The Mixtape. Yale University Press.\n高橋将宜. 2022. 『統計的因果推論の理論と実装』共立出版."
  },
  {
    "objectID": "syllabus.html#講義内容",
    "href": "syllabus.html#講義内容",
    "title": "本講義について",
    "section": "講義内容",
    "text": "講義内容\n以下の内容は履修者の理解度や進捗状況に応じて変更される可能性がある。\n\n\n\n回\n講義日\n内容\n\n\n\n\n1\n2022/09/26\nガイダンス\n\n\n2\n2022/10/03\n因果推論の考え方\n\n\n3\n2022/10/10\n無作為化比較試験\n\n\n4\n2022/10/17\nRの復習\n\n\n5\n2022/10/24\nRの復習\n\n\n6\n2022/10/31\n回帰分析と因果推論\n\n\n7\n2022/11/07\nマッチング（理論）\n\n\n8\n2022/11/14\nマッチング（実習）\n\n\n9\n2022/11/21\n差分の差分法（理論）\n\n\n10\n2022/11/28\n差分の差分法（実習）\n\n\n11\n2022/12/05\n回帰不連続デザイン（理論）\n\n\n12\n2022/12/12\n回帰不連続デザイン（実習）\n\n\n13\n2022/12/19\n操作変数法（理論）\n\n\n14\n2022/12/26\n操作変数法（実習）\n\n\n15\n2023/01/16\n研究構想の発表"
  },
  {
    "objectID": "material/day04.html",
    "href": "material/day04.html",
    "title": "Rの復習",
    "section": "",
    "text": "通常、Rでのパッケージのインストールとアップーでとにはinstall.packages()関数、読み込みにはlibrary()、またはrequire()関数を使う。また、R公式レポジトリにないパッケージは{devtools}か{remote}パッケージを使う。これらの関数を使い分けることは面倒なので、本講義ではこれらの処理を統合した{pacman}パッケージを使用する。まずは、{pacman}パッケージをインストールする。\n\n# NIIオンライン分析システムを利用する場合、導入済み\ninstall.packages(\"pacman\")\n\n　パッケージを読み込む際、pacman::p_load(読み込むパッケージ名)を入力する。インストールされていない場合は、自動的にCRANからダウンロード&インストールした上で読み込んでくれるので便利だ1。以下では本講義で使用するパッケージとして{tidyverse}、{summarytools}、{fastDummies}、{modelsummary}を読み込む。\n\npacman::p_load(tidyverse, summarytools, fastDummies,\n               modelsummary, broom)\n\n　CRANでなく、GitHub上で公開されているパッケージを使う場合はpacman::p_load_gh()を使用する。()の中には\"ユーザー名/リポジトリ名\"を入力。たとえば、{BalanceR}の作成者のGitHubアカウント名はJaehyunSongであり、{BalanceR}のリポジトリ名はBalanceRだから、以下のように入力する。\n\npacman::p_load_gh(\"JaehyunSong/BalanceR\")"
  },
  {
    "objectID": "material/day04.html#データの読み込みと確認",
    "href": "material/day04.html#データの読み込みと確認",
    "title": "Rの復習",
    "section": "データの読み込みと確認",
    "text": "データの読み込みと確認\n　.csv形式のデータを読み込むにはread_csv()関数を使用する。()内には読み込むファイルのパスを\"で囲んで記入する。read_csv()関数はファイルの読み込みのみの機能しか持たない。現在の作業環境内に読み込んだデータを格納するためには代入演算子<-を使う。ここではdataフォルダー内のrct_data.csvを読み込み2、raw_dfという名のオブジェクトとしてく格納する。作業環境内のオブジェクトはRを再起動すると削除されるため、改めてパッケージ/データの読み込みが必要だ。\n\nraw_df <- read_csv(\"data/rct_data.csv\")\n\nRows: 5000 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (6): treatment, gender, voted2000, voted2002, voted2004, voted2006\ndbl (2): yob, hh_size\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n　オブジェクトの中身を出力するためにはオブジェクト名を入力する。\n\nraw_df\n\n# A tibble: 5,000 × 8\n   treatment  gender   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>    \n 1 Hawthorne  female  1955       1 no        yes       no        no       \n 2 Hawthorne  male    1969       2 no        yes       no        no       \n 3 Control    female  1944       2 no        no        no        no       \n 4 Control    male    1974       2 no        no        yes       no       \n 5 Neighbors  female  1969       2 no        no        yes       no       \n 6 Control    male    1942       1 no        yes       no        no       \n 7 Civic Duty male    1969       2 yes       no        no        no       \n 8 Hawthorne  male    1966       2 no        yes       no        yes      \n 9 Control    male    1949       2 no        yes       yes       no       \n10 Control    female  1958       2 no        yes       no        no       \n# … with 4,990 more rows\n\n\n　表形式データの大きさ（行の列の数）の確認にはdim()関数を使う。\n\ndim(raw_df)\n\n[1] 5000    8\n\n\n　表形式データの場合、各列には名前が付いており、それぞれが一つの変数に該当する。これら変数名のみの出力にはnames()関数を使う。今回のデータだと、列の数が少ないこともあり、一画面に全列が表示されるが、数百列のデータとなると画面に収まらないので、変数名を確認しておくことを推奨する。\n\nnames(raw_df)\n\n[1] \"treatment\" \"gender\"    \"yob\"       \"hh_size\"   \"voted2000\" \"voted2002\"\n[7] \"voted2004\" \"voted2006\""
  },
  {
    "objectID": "material/day04.html#データハンドリングとパイプ演算子",
    "href": "material/day04.html#データハンドリングとパイプ演算子",
    "title": "Rの復習",
    "section": "データハンドリングとパイプ演算子",
    "text": "データハンドリングとパイプ演算子\n　パイプ演算子には{magrittr}パッケージが提供する%>%とR 4.1から提供されるネイティブパイプ演算子の|>がある。現在の主流は古くから使われてきた%>%であるが、今後、|>が主流になると考えられるため、本講義では|>を使用する。しかし、多くの場合、|>の代わりに%>%を使っても同じ結果が得られる。\n　パイプ演算子はパイプ前のオブジェクトを、パイプ後の関数の第一引数として渡す単純な演算子だ。たとえば、列名を変更する関数はrename()であるが、使い方はrenames(データ名, 新しい列名 = 既存の列名, ...)である。raw_dfのgender列の名前をfemaleに変更する場合は以下のように書く。\n\nrename(raw_df, female = gender)\n\n# A tibble: 5,000 × 8\n   treatment  female   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>    \n 1 Hawthorne  female  1955       1 no        yes       no        no       \n 2 Hawthorne  male    1969       2 no        yes       no        no       \n 3 Control    female  1944       2 no        no        no        no       \n 4 Control    male    1974       2 no        no        yes       no       \n 5 Neighbors  female  1969       2 no        no        yes       no       \n 6 Control    male    1942       1 no        yes       no        no       \n 7 Civic Duty male    1969       2 yes       no        no        no       \n 8 Hawthorne  male    1966       2 no        yes       no        yes      \n 9 Control    male    1949       2 no        yes       yes       no       \n10 Control    female  1958       2 no        yes       no        no       \n# … with 4,990 more rows\n\n\n　ここで第1引数がraw_dfだが、パイプ演算子を使うと以下のようになり、人間にとって読みやすいコードになる。\n\nraw_df |>\n  rename(female = gender)\n\n# A tibble: 5,000 × 8\n   treatment  female   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>    \n 1 Hawthorne  female  1955       1 no        yes       no        no       \n 2 Hawthorne  male    1969       2 no        yes       no        no       \n 3 Control    female  1944       2 no        no        no        no       \n 4 Control    male    1974       2 no        no        yes       no       \n 5 Neighbors  female  1969       2 no        no        yes       no       \n 6 Control    male    1942       1 no        yes       no        no       \n 7 Civic Duty male    1969       2 yes       no        no        no       \n 8 Hawthorne  male    1966       2 no        yes       no        yes      \n 9 Control    male    1949       2 no        yes       yes       no       \n10 Control    female  1958       2 no        yes       no        no       \n# … with 4,990 more rows\n\n\n　要するに、X |> Yは「X（の結果）を使ってYを行う」ことを意味する。\n　続いて、変数のリコーディングをしてみよう。xの値が\"A\"なら1、それ以外は0のように、戻り値が2種類の場合のリコーディングにはif_else()を使用する。書き方は以下の通りだ。\n\nif_else(条件式, 条件が満たされる場合の戻り値, 条件が満たされない場合の戻り値)\n\n　たとえば、raw_dfのgender列の値が\"female\"なら1、それ以外なら0とし、その結果をfemale列として追加するコードは以下の通り。同値を意味する演算子が=でなく、==であることに注意すること（=は<-と同じ代入演算子であるが、Rでは代入演算子として=より<-の使用を推奨している）。\n\nmutate(raw_df, \n       female = if_else(gender == \"female\", 1, 0))\n\n# A tibble: 5,000 × 9\n   treatment  gender   yob hh_size voted2000 voted2002 voted2004 voted2…¹ female\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>     <dbl>\n 1 Hawthorne  female  1955       1 no        yes       no        no            1\n 2 Hawthorne  male    1969       2 no        yes       no        no            0\n 3 Control    female  1944       2 no        no        no        no            1\n 4 Control    male    1974       2 no        no        yes       no            0\n 5 Neighbors  female  1969       2 no        no        yes       no            1\n 6 Control    male    1942       1 no        yes       no        no            0\n 7 Civic Duty male    1969       2 yes       no        no        no            0\n 8 Hawthorne  male    1966       2 no        yes       no        yes           0\n 9 Control    male    1949       2 no        yes       yes       no            0\n10 Control    female  1958       2 no        yes       no        no            1\n# … with 4,990 more rows, and abbreviated variable name ¹​voted2006\n\n\n　mutate()は指定された列に対して何らかの処理を行い、その結果を新しい列として追加するか、上書きする関数である。このmutate()関数の第1引数もデータであるため、以下のようにパイプ演算子を使うこともできる。\n\nraw_df |>\n  mutate(female = if_else(gender == \"female\", 1, 0))\n\n# A tibble: 5,000 × 9\n   treatment  gender   yob hh_size voted2000 voted2002 voted2004 voted2…¹ female\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>     <dbl>\n 1 Hawthorne  female  1955       1 no        yes       no        no            1\n 2 Hawthorne  male    1969       2 no        yes       no        no            0\n 3 Control    female  1944       2 no        no        no        no            1\n 4 Control    male    1974       2 no        no        yes       no            0\n 5 Neighbors  female  1969       2 no        no        yes       no            1\n 6 Control    male    1942       1 no        yes       no        no            0\n 7 Civic Duty male    1969       2 yes       no        no        no            0\n 8 Hawthorne  male    1966       2 no        yes       no        yes           0\n 9 Control    male    1949       2 no        yes       yes       no            0\n10 Control    female  1958       2 no        yes       no        no            1\n# … with 4,990 more rows, and abbreviated variable name ¹​voted2006\n\n\n　また、mutate()内には複数のコードを書くこともできる。voted2000列からvoted2006列までそれぞれの値が\"yes\"であれば、1を、それ以外の場合は0にリコーディングしてみよう。\n\nraw_df |>\n  mutate(female    = if_else(gender    == \"female\", 1, 0),\n         voted2000 = if_else(voted2000 == \"yes\", 1, 0),\n         voted2002 = if_else(voted2002 == \"yes\", 1, 0),\n         voted2004 = if_else(voted2004 == \"yes\", 1, 0),\n         voted2006 = if_else(voted2006 == \"yes\", 1, 0))\n\n# A tibble: 5,000 × 9\n   treatment  gender   yob hh_size voted2000 voted2002 voted2004 voted2…¹ female\n   <chr>      <chr>  <dbl>   <dbl>     <dbl>     <dbl>     <dbl>    <dbl>  <dbl>\n 1 Hawthorne  female  1955       1         0         1         0        0      1\n 2 Hawthorne  male    1969       2         0         1         0        0      0\n 3 Control    female  1944       2         0         0         0        0      1\n 4 Control    male    1974       2         0         0         1        0      0\n 5 Neighbors  female  1969       2         0         0         1        0      1\n 6 Control    male    1942       1         0         1         0        0      0\n 7 Civic Duty male    1969       2         1         0         0        0      0\n 8 Hawthorne  male    1966       2         0         1         0        1      0\n 9 Control    male    1949       2         0         1         1        0      0\n10 Control    female  1958       2         0         1         0        0      1\n# … with 4,990 more rows, and abbreviated variable name ¹​voted2006\n\n\n　また、パイプ演算子は2つ以上使うこともできる。たとえば、rename()を使ってgender列をfemaleに変更し、mutate()でリコーディングを行う場合、以下のように書く。これはraw_dfを使ってrename()の処理を行い、その結果をmutate()関数のデータとして渡すことを意味する。\n\nraw_df |>\n  rename(female = gender) |>\n  mutate(female    = if_else(female    == \"female\", 1, 0),\n         voted2000 = if_else(voted2000 == \"yes\", 1, 0),\n         voted2002 = if_else(voted2002 == \"yes\", 1, 0),\n         voted2004 = if_else(voted2004 == \"yes\", 1, 0),\n         voted2006 = if_else(voted2006 == \"yes\", 1, 0))\n\n# A tibble: 5,000 × 8\n   treatment  female   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>       <dbl> <dbl>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n 1 Hawthorne       1  1955       1         0         1         0         0\n 2 Hawthorne       0  1969       2         0         1         0         0\n 3 Control         1  1944       2         0         0         0         0\n 4 Control         0  1974       2         0         0         1         0\n 5 Neighbors       1  1969       2         0         0         1         0\n 6 Control         0  1942       1         0         1         0         0\n 7 Civic Duty      0  1969       2         1         0         0         0\n 8 Hawthorne       0  1966       2         0         1         0         1\n 9 Control         0  1949       2         0         1         1         0\n10 Control         1  1958       2         0         1         0         0\n# … with 4,990 more rows\n\n\n　以上のコードはデータを加工し、その結果を出力するだけであって、その結果を保存しない。もう一度raw_dfを出力してみても、これまでのデータ加工内容は反映されていないことが分かる。\n\nraw_df\n\n# A tibble: 5,000 × 8\n   treatment  gender   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>      <chr>  <dbl>   <dbl> <chr>     <chr>     <chr>     <chr>    \n 1 Hawthorne  female  1955       1 no        yes       no        no       \n 2 Hawthorne  male    1969       2 no        yes       no        no       \n 3 Control    female  1944       2 no        no        no        no       \n 4 Control    male    1974       2 no        no        yes       no       \n 5 Neighbors  female  1969       2 no        no        yes       no       \n 6 Control    male    1942       1 no        yes       no        no       \n 7 Civic Duty male    1969       2 yes       no        no        no       \n 8 Hawthorne  male    1966       2 no        yes       no        yes      \n 9 Control    male    1949       2 no        yes       yes       no       \n10 Control    female  1958       2 no        yes       no        no       \n# … with 4,990 more rows\n\n\n　このように頑張ってデータを加工したもののその結果が全く反映されていない。加工したデータを引き続き使っていくためには、加工結果を作業環境内に保存する必要がある。作業環境内にオブジェクトを保存するためには代入演算子（<-）を使い、名前を付けて作業空間内に保存する（ファイルとして保存されるわけではない）必要がある。今回は加工の結果をdfという名で保存する。raw_dfに上書きしても問題はないが、生データはとりあえず作業空間内に残しておくことを推奨する（Rに慣れれば上書きしても良い）。\n\ndf <- raw_df |>\n  rename(female = gender) |>\n  mutate(female    = if_else(female    == \"female\", 1, 0),\n         voted2000 = if_else(voted2000 == \"yes\", 1, 0),\n         voted2002 = if_else(voted2002 == \"yes\", 1, 0),\n         voted2004 = if_else(voted2004 == \"yes\", 1, 0),\n         voted2006 = if_else(voted2006 == \"yes\", 1, 0))\n\ndf\n\n# A tibble: 5,000 × 8\n   treatment  female   yob hh_size voted2000 voted2002 voted2004 voted2006\n   <chr>       <dbl> <dbl>   <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n 1 Hawthorne       1  1955       1         0         1         0         0\n 2 Hawthorne       0  1969       2         0         1         0         0\n 3 Control         1  1944       2         0         0         0         0\n 4 Control         0  1974       2         0         0         1         0\n 5 Neighbors       1  1969       2         0         0         1         0\n 6 Control         0  1942       1         0         1         0         0\n 7 Civic Duty      0  1969       2         1         0         0         0\n 8 Hawthorne       0  1966       2         0         1         0         1\n 9 Control         0  1949       2         0         1         1         0\n10 Control         1  1958       2         0         1         0         0\n# … with 4,990 more rows\n\n\n　ちなみに、across()関数とラムダ式（無名関数）を組み合わせると以上のコードをより効率的に書くこともできる。across()は強力な関数だが、初心者にはやや難しいかも知れない。詳細は『私たちのR』の第13.1章を参照されたい。\n\ndf <- raw_df |>\n  rename(female = gender) |>\n  mutate(female = if_else(female == \"female\", 1, 0),\n         # 第1引数: votedで始まる変数を対象に処理を行う\n         # 第2引数: 当該変数の値が\"yes\"なら1、それ以外なら0を割り当てる無名関数\n         #          無名関数は「~」で始まり、変数が入る箇所は.xと表記する\n         #          引数が当該変数のみであれば、「~」を付けずに関数のみでもOK\n         across(starts_with(\"voted\"), ~if_else(.x == \"yes\", 1, 0)))"
  },
  {
    "objectID": "material/day04.html#記述統計量",
    "href": "material/day04.html#記述統計量",
    "title": "Rの復習",
    "section": "記述統計量",
    "text": "記述統計量\n　記述統計量の計算には{summarytools}のdescr()関数が便利だ。descr(データ名)を入力するだけで各変数の記述統計量が出力される。実際にやってみると分かるが、情報量がかなり多い。しかし、実際の論文では各変数の歪度や尖度まで報告することはあまりないだろう。ここではstats引数を追加して、論文などでよく使う平均値（\"mean\"）、標準偏差（\"sd\"）、最小値（\"min\"）、最大値（\"max\"）、有効ケース数（\"n.valid\"）のみ出力する。\n\n# descr()の第一引数は表形式データのオブジェクト名であるため、\n# オブジェクト名 |> descr() \n# のような書き方でもOK\ndf |>\n  descr(stats = c(\"mean\", \"sd\", \"min\", \"max\", \"n.valid\"))\n\nNon-numerical variable(s) ignored: treatment\n\n\nDescriptive Statistics  \ndf  \nN: 5000  \n\n                 female   hh_size   voted2000   voted2002   voted2004   voted2006       yob\n------------- --------- --------- ----------- ----------- ----------- ----------- ---------\n         Mean      0.50      2.18        0.26        0.39        0.41        0.33   1955.75\n      Std.Dev      0.50      0.79        0.44        0.49        0.49        0.47     14.41\n          Min      0.00      1.00        0.00        0.00        0.00        0.00   1910.00\n          Max      1.00      6.00        1.00        1.00        1.00        1.00   1986.00\n      N.Valid   5000.00   5000.00     5000.00     5000.00     5000.00     5000.00   5000.00\n\n\n　ただし、descr()を使うと数値型（numeric）変数の記述統計量のみ表示される。dfだと、treatment列は文字型（character）であるため、表示されない3。各グループがサンプルの何割かを計算するためには、treatment変数をダミー変数へ変換する必要がある。ダミー変数の作成は面倒な作業であるが、{fastDummies}パッケージのdummy_cols()を使えば簡単にできる。dummy_cols()の中にはselect_columns = \"ダミー化する列名\"を入れれば、当該変数をダミー変数へ変換し、新しい列として追加してくれる。それではtreatment列をダミー化&追加し、その結果をdfに上書きしてみよう。\n\ndf <- df |>\n  dummy_cols(select_columns = \"treatment\")\n\ndf\n\n# A tibble: 5,000 × 13\n   treatm…¹ female   yob hh_size voted…² voted…³ voted…⁴ voted…⁵ treat…⁶ treat…⁷\n   <chr>     <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <int>   <int>\n 1 Hawthor…      1  1955       1       0       1       0       0       0       0\n 2 Hawthor…      0  1969       2       0       1       0       0       0       0\n 3 Control       1  1944       2       0       0       0       0       0       1\n 4 Control       0  1974       2       0       0       1       0       0       1\n 5 Neighbo…      1  1969       2       0       0       1       0       0       0\n 6 Control       0  1942       1       0       1       0       0       0       1\n 7 Civic D…      0  1969       2       1       0       0       0       1       0\n 8 Hawthor…      0  1966       2       0       1       0       1       0       0\n 9 Control       0  1949       2       0       1       1       0       0       1\n10 Control       1  1958       2       0       1       0       0       0       1\n# … with 4,990 more rows, 3 more variables: treatment_Hawthorne <int>,\n#   treatment_Neighbors <int>, treatment_Self <int>, and abbreviated variable\n#   names ¹​treatment, ²​voted2000, ³​voted2002, ⁴​voted2004, ⁵​voted2006,\n#   ⁶​`treatment_Civic Duty`, ⁷​treatment_Control\n\n\n　画面には表示されないが、出力結果の下段を見るとtreatment_で始まるいくつかの変数が追加されたことが分かる。ここでは\"tretmant\"で始まる列のみを抽出つして確認してみよう。\n\ndf |>\n  select(starts_with(\"treatment\"))\n\n# A tibble: 5,000 × 6\n   treatment  `treatment_Civic Duty` treatment_Control treatme…¹ treat…² treat…³\n   <chr>                       <int>             <int>     <int>   <int>   <int>\n 1 Hawthorne                       0                 0         1       0       0\n 2 Hawthorne                       0                 0         1       0       0\n 3 Control                         0                 1         0       0       0\n 4 Control                         0                 1         0       0       0\n 5 Neighbors                       0                 0         0       1       0\n 6 Control                         0                 1         0       0       0\n 7 Civic Duty                      1                 0         0       0       0\n 8 Hawthorne                       0                 0         1       0       0\n 9 Control                         0                 1         0       0       0\n10 Control                         0                 1         0       0       0\n# … with 4,990 more rows, and abbreviated variable names ¹​treatment_Hawthorne,\n#   ²​treatment_Neighbors, ³​treatment_Self\n\n\n　select()関数内には抽出する列名を入力するだけで良い。たとえば、femaleとyob列を抽出するならselect(female, yob)である。また、femaleからvoted2006までの意味でfemale:voted2006のような書き方もできる。他にも上の例のようにstarts_with()やends_with()、contain()を使って特定の文字列で始まる（で終わる、を含む）列を指定することもできる。一部の列を除外する場合は変数名の前に!か-を付ける。\n　とにかく、問題なくダミー化されていることが分かる。もう一度記述統計量を出してみよう。descr()は仕様上、出力される変数の順番はアルファベット順になるが、ここでは元の順番を維持するためにorder = \"p\"を追加する。また、通常の記述統計表が、先ほど見たものとは違って、各行が変数を、列は記述統計量を表す場合が多い。このように行と列を交換するためにはtranspose = TRUEを追加する4。\ndf |>\n  descr(stats = c(\"mean\", \"sd\", \"min\", \"max\", \"n.valid\"),\n        order = \"p\", transpose = TRUE, headings = FALSE)\nNon-numerical variable(s) ignored: treatment\n\n\n\n\nMean\nStd.Dev\nMin\nMax\nN.Valid\n\n\n\n\nfemale\n0.50\n0.50\n0.00\n1.00\n5000.00\n\n\nyob\n1955.75\n14.41\n1910.00\n1986.00\n5000.00\n\n\nhh_size\n2.18\n0.79\n1.00\n6.00\n5000.00\n\n\nvoted2000\n0.26\n0.44\n0.00\n1.00\n5000.00\n\n\nvoted2002\n0.39\n0.49\n0.00\n1.00\n5000.00\n\n\nvoted2004\n0.41\n0.49\n0.00\n1.00\n5000.00\n\n\nvoted2006\n0.33\n0.47\n0.00\n1.00\n5000.00\n\n\ntreatment_Civic Duty\n0.12\n0.32\n0.00\n1.00\n5000.00\n\n\ntreatment_Control\n0.56\n0.50\n0.00\n1.00\n5000.00\n\n\ntreatment_Hawthorne\n0.11\n0.32\n0.00\n1.00\n5000.00\n\n\ntreatment_Neighbors\n0.11\n0.31\n0.00\n1.00\n5000.00\n\n\ntreatment_Self\n0.11\n0.31\n0.00\n1.00\n5000.00\n\n\n\n　他にも以下のようにdfSummary()関数を使えば、綺麗な表としてまとめてくれる。しかも文字型、factor型変数の場合も度数分布表を作成してくれるので非常に便利だ。これも{summarytools}パッケージに含まれた機能なので、別途、パッケージを読み込む必要はない。\n\ndf |>\n  select(-starts_with(\"treatment_\")) |>\n  dfSummary(headings = FALSE) |> \n  print(method = \"render\", round.digits = 3)\n\n\n\n\n  \n    \n      No\n      Variable\n      Stats / Values\n      Freqs (% of Valid)\n      Graph\n      Valid\n      Missing\n    \n  \n  \n    \n      1\n      treatment\n[character]\n      1. Civic Duty2. Control3. Hawthorne4. Neighbors5. Self\n      578(11.6%)2777(55.5%)572(11.4%)535(10.7%)538(10.8%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      2\n      female\n[numeric]\n      Min  : 0Mean : 0.5Max  : 1\n      0:2494(49.9%)1:2506(50.1%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      3\n      yob\n[numeric]\n      Mean (sd) : 1955.8 (14.4)min ≤ med ≤ max:1910 ≤ 1956 ≤ 1986IQR (CV) : 18 (0)\n      76 distinct values\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      4\n      hh_size\n[numeric]\n      Mean (sd) : 2.2 (0.8)min ≤ med ≤ max:1 ≤ 2 ≤ 6IQR (CV) : 0 (0.4)\n      1:699(14.0%)2:3112(62.2%)3:831(16.6%)4:308(6.2%)5:45(0.9%)6:5(0.1%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      5\n      voted2000\n[numeric]\n      Min  : 0Mean : 0.3Max  : 1\n      0:3722(74.4%)1:1278(25.6%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      6\n      voted2002\n[numeric]\n      Min  : 0Mean : 0.4Max  : 1\n      0:3058(61.2%)1:1942(38.8%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      7\n      voted2004\n[numeric]\n      Min  : 0Mean : 0.4Max  : 1\n      0:2941(58.8%)1:2059(41.2%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n    \n      8\n      voted2006\n[numeric]\n      Min  : 0Mean : 0.3Max  : 1\n      0:3373(67.5%)1:1627(32.5%)\n      \n      5000\n(100.0%)\n      0\n(0.0%)\n    \n  \n\nGenerated by summarytools 1.0.1 (R version 4.2.1)2022-09-16"
  },
  {
    "objectID": "material/day04.html#バランスチェック",
    "href": "material/day04.html#バランスチェック",
    "title": "Rの復習",
    "section": "バランスチェック",
    "text": "バランスチェック\n　バランスチェックの簡単な方法はグループごとに処置前変数（pre-treatment variables）の平均値を比較することである。無作為割当が成功しているのであれば、処置前に測定された変数の平均値は近似するはずである。ここではグループ（treatment）ごとに性別、誕生年、世帯規模、2000〜2004年の投票参加の平均値を比較してみる。\n\ndf |>\n  group_by(treatment) |>\n  summarise(female    = mean(female, na.rm = TRUE),\n            yob       = mean(yob, na.rm = TRUE),\n            hh_size   = mean(hh_size, na.rm = TRUE),\n            voted2000 = mean(voted2000, na.rm = TRUE),\n            voted2002 = mean(voted2002, na.rm = TRUE),\n            voted2004 = mean(voted2004, na.rm = TRUE))\n\n# A tibble: 5 × 7\n  treatment  female   yob hh_size voted2000 voted2002 voted2004\n  <chr>       <dbl> <dbl>   <dbl>     <dbl>     <dbl>     <dbl>\n1 Civic Duty  0.517 1957.    2.22     0.239     0.374     0.394\n2 Control     0.491 1956.    2.17     0.261     0.390     0.411\n3 Hawthorne   0.507 1956.    2.23     0.257     0.385     0.416\n4 Neighbors   0.507 1955.    2.13     0.247     0.406     0.439\n5 Self        0.526 1956.    2.19     0.253     0.383     0.401\n\n\n　それぞれの変数の平均値は非常に似ているため、無作為割当が成功したと考えられる。しかし、変数の単位によって判断が難しいかも知れない。たとえば、2つのグループがあり、年齢の平均値の差は3、世帯規模のそれは2だとする。これを見ると年齢の方がよりバランスが取れていないようにも見えるが、年齢の幅は数十であるに対し、世帯規模はせいぜい5〜6程度であろう。したがって、各変数のばらつきまで考慮した比較が適切であり、その方法の一つが標準化バイアス（=標準化差分）である。\n　標準化差分を計算する便利パッケージ、{BalanceR}を使ってみよう。第1引数はデータだから、パイプで渡せば良い。BalanceR()内にはgroup引数にグループ識別変数を、covには処置前変数のベクトルを入れる。\n\nblc_chk <- df |>\n  BalanceR(group = treatment,\n           cov   = c(female, yob, hh_size, voted2000, voted2002, voted2004))\n\nblc_chk\n\n  Covariate Mean:Civic Duty SD:Civic Duty Mean:Control SD:Control\n1    female           0.517         0.500        0.491      0.500\n2       yob        1957.304        14.515     1955.555     14.453\n3   hh_size           2.225         0.810        2.169      0.777\n4 voted2000           0.239         0.427        0.261      0.439\n5 voted2002           0.374         0.484        0.390      0.488\n6 voted2004           0.394         0.489        0.411      0.492\n  Mean:Hawthorne SD:Hawthorne Mean:Neighbors SD:Neighbors Mean:Self SD:Self\n1          0.507        0.500          0.507        0.500     0.526   0.500\n2       1955.909       14.638       1954.976       14.510  1955.719  13.639\n3          2.231        0.809          2.129        0.786     2.193   0.772\n4          0.257        0.437          0.247        0.432     0.253   0.435\n5          0.385        0.487          0.406        0.491     0.383   0.487\n6          0.416        0.493          0.439        0.497     0.401   0.491\n  SB:Civic Duty-Control SB:Civic Duty-Hawthorne SB:Civic Duty-Neighbors\n1                 5.299                   2.062                   2.153\n2                12.082                   9.573                  16.047\n3                 7.102                  -0.723                  12.018\n4                -5.157                  -4.225                  -1.860\n5                -3.353                  -2.249                  -6.546\n6                -3.420                  -4.405                  -9.094\n  SB:Civic Duty-Self SB:Control-Hawthorne SB:Control-Neighbors SB:Control-Self\n1             -1.746               -3.236               -3.145          -7.046\n2             11.255               -2.437                3.997          -1.173\n3              3.994               -7.847                5.060          -3.199\n4             -3.260                0.931                3.296           1.896\n5             -1.897                1.103               -3.191           1.456\n6             -1.435               -0.985               -5.669           1.985\n  SB:Hawthorne-Neighbors SB:Hawthorne-Self SB:Neighbors-Self\n1                  0.090            -3.809            -3.899\n2                  6.404             1.341            -5.281\n3                 12.763             4.739            -8.258\n4                  2.365             0.965            -1.400\n5                 -4.295             0.353             4.648\n6                 -4.684             2.970             7.656\n\n\n　ちなみに、df内にfemaleからvoted2004は連続している（names(df)で確認してみよう）。この場合は以下のように（female:voted2004）書き換えることもできる。\n\nblc_chk <- df |>\n  BalanceR(group = treatment,\n           cov   = female:voted2004)\n\nblc_chk\n\n　標準化差分（標準化バイアス）を用いたバランスチェックはそれぞれのペアごとに計算を行うため、グループが多い場合は凡例が圧迫される場合が多い。しかし、重要なのは標準化差分の最大値だろう。ペア1、2、3でバランスが取れても、ペア4のバランスが取られていない場合は無意味だからだ。また、標準化差分の場合、符号の意味はなく、絶対値が重要だ。また、バランスチェックにおいてグループごとの平均値や標準偏差は不要である。ここでsummary()関数を使うと、絶対値が最も大きい標準化差分のみ出力される。\n\nsummary(blc_chk)\n\n  Covariate Abs_Maximum_SB\n1    female          7.046\n2       yob         16.047\n3   hh_size         12.763\n4 voted2000          5.157\n5 voted2002          6.546\n6 voted2004          9.094\n\n\n　plot()関数を使えば、これらの結果を可視化することもできる。\n\nplot(blc_chk)\n\n\n\n\n図 1: ?(caption)\n\n\n\n\n　先ほど述べたようにバランスチェックで重要なのは絶対値が最も大きい標準化差分である。plot()内にsimplify = TRUEを指定すれば最大値のみ表示され、更にabs = TRUEにすると絶対値へ変換される。また、垂直のガイドラインはvline引数で変更できる。\n\n# plot() の第1引数は blc_chk なのでパイプの使える\nblc_chk |>\n  plot(vline = c(5, 10), simplify = TRUE, abs = TRUE)\n\n\n\n\n図 2: ?(caption)"
  },
  {
    "objectID": "material/day04.html#処置効果の確認",
    "href": "material/day04.html#処置効果の確認",
    "title": "Rの復習",
    "section": "処置効果の確認",
    "text": "処置効果の確認\n\nグループごとの応答変数の平均値\n　処置効果を確認するためには各グループごとの応答変数（ここではvoted2006）の平均値を計算し、処置群の平均値から統制群の平均値を引く必要がある。まずは、特定の変数の平均値を計算する方法について紹介する。データ内にある特定の変数の平均値を計算するためにはsummarise()関数内に平均値を求めるmean()関数を入れる。たとえば、dfのvoted2006の平均値を計算するコードは以下の通りである。\n\ndf |>\n  summarise(mean(voted2006, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  `mean(voted2006, na.rm = TRUE)`\n                            <dbl>\n1                           0.325\n\n\n　na.rm = TRUEは「欠損値があれば、それを除外する」を意味し、指定されていない場合（=既定値）はFALSEになる。今回は欠損値がないものの、念の為に入れておく。\n　出力結果を見ると、平均値が表示される列の名前が`mean(voted2006, na.rm = TRUE)`となっており、非常に見にくい。この場合、以下のようにmean()の前に出力される列名を予め指定することもできる。\n\ndf |>\n  # voted2006の平均値が表示される列名を Outcome にする。\n  summarise(Outcome = mean(voted2006, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  Outcome\n    <dbl>\n1   0.325\n\n\n　我々が知りたいのはvoted2006の平均値でなく、グループごとの平均値だろう。被験者がどのグループに属しているかわ示す変数はtreatmentであるが、summarise()にデータを渡す前にgroup_by()変数を使うと、グループごとに計算を行い、その結果を返す。\n\ndf |>\n  group_by(treatment) |>\n  summarise(Outcome = mean(voted2006, na.rm = TRUE))\n\n# A tibble: 5 × 2\n  treatment  Outcome\n  <chr>        <dbl>\n1 Civic Duty   0.317\n2 Control      0.299\n3 Hawthorne    0.339\n4 Neighbors    0.421\n5 Self         0.364\n\n\n　group_by()内でも=演算子を使うと、グループ名が出力される列名を変更することができる。\n\ndf |>\n  # グループ名が表示される列名を Group にする。\n  group_by(Groups = treatment) |>\n  summarise(Outcome = mean(voted2006, na.rm = TRUE))\n\n# A tibble: 5 × 2\n  Groups     Outcome\n  <chr>        <dbl>\n1 Civic Duty   0.317\n2 Control      0.299\n3 Hawthorne    0.339\n4 Neighbors    0.421\n5 Self         0.364\n\n\n　ここで一つ注目したいのが、グループの表示順番である。変数のデータ型が文字型だと（Rコンソール上でclass(df$treatment)を入力するか、dfの出力画面でtreatmentの下に<chr>と表示されていることで確認できる）、今のようにアルファベット順で表示される。しかし、統制群は最初か最後に来るのが通例である。この順番をアルファベット順でなく、任意の順番にするためにはtreatment変数をfactor型変数へ変換する必要がある。Factor型は「順序付きの文字型変数」だと理解しても良い5。列の追加・上書き（今回はtreatment列の上書き）の処理が必要なのでmutate()関数を使う。変数をfactor型に変換する関数はfactor()関数で、第1引数としてはfactor型へ変換する変数名を指定する。第2引数はlevelsであり、出力したい順番の文字型ベクトルを指定する。スペルミスに注意すること。\n\ndf |>\n  mutate(treatment = factor(treatment,\n                            levels = c(\"Control\", \"Civic Duty\",\n                                       \"Self\", \"Neighbors\", \"Hawthorne\")))\n\n# A tibble: 5,000 × 13\n   treatm…¹ female   yob hh_size voted…² voted…³ voted…⁴ voted…⁵ treat…⁶ treat…⁷\n   <fct>     <dbl> <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <int>   <int>\n 1 Hawthor…      1  1955       1       0       1       0       0       0       0\n 2 Hawthor…      0  1969       2       0       1       0       0       0       0\n 3 Control       1  1944       2       0       0       0       0       0       1\n 4 Control       0  1974       2       0       0       1       0       0       1\n 5 Neighbo…      1  1969       2       0       0       1       0       0       0\n 6 Control       0  1942       1       0       1       0       0       0       1\n 7 Civic D…      0  1969       2       1       0       0       0       1       0\n 8 Hawthor…      0  1966       2       0       1       0       1       0       0\n 9 Control       0  1949       2       0       1       1       0       0       1\n10 Control       1  1958       2       0       1       0       0       0       1\n# … with 4,990 more rows, 3 more variables: treatment_Hawthorne <int>,\n#   treatment_Neighbors <int>, treatment_Self <int>, and abbreviated variable\n#   names ¹​treatment, ²​voted2000, ³​voted2002, ⁴​voted2004, ⁵​voted2006,\n#   ⁶​`treatment_Civic Duty`, ⁷​treatment_Control\n\n\n　treatment列名の下が<fct>となっていることが分かる。これはtreatment列のデータ型がfactor型であることを意味する。問題なく動くことが確認できたので、dfを上書きしよう。\n\ndf <- df |>\n  mutate(treatment = factor(treatment,\n                            levels = c(\"Control\", \"Civic Duty\",\n                                       \"Self\", \"Neighbors\", \"Hawthorne\")))\n\n　それでは、改めてグループごとのvoted2006の平均値を計算してみよう。今回は計算結果をout_mean_dfという名のオブジェクトとして格納する。\n\nout_mean_df <- df |>\n  group_by(Groups = treatment) |>\n  summarise(Outcome = mean(voted2006, na.rm = TRUE))\n\nout_mean_df\n\n# A tibble: 5 × 2\n  Groups     Outcome\n  <fct>        <dbl>\n1 Control      0.299\n2 Civic Duty   0.317\n3 Self         0.364\n4 Neighbors    0.421\n5 Hawthorne    0.339\n\n\n　今回は統制群は最初に出力されていることが確認できる。\n　それではこの結果をグラフとして示してみよう。作図には{ggplot2}パッケージを使う。まずはout_mean_dfをggplot()関数に渡す。ggplot()関数以降は、+演算子を使ってレイヤーを足していくこととなる。棒グラフのレイヤーはgeom_bar()関数であり、その中にaes()関数を入れる。aes()の中には棒グラフの作図に必要な情報を入れる必要がある（これをマッピング（mapping）と呼ぶ）。棒グラフを作成するために必要な最低限の情報とは各棒の横軸上の位置（x）と棒の高さ（y）だ。今回は横軸がグループ名、縦軸が平均値となる棒グラフを作る。aes()外側にはstat = \"identity\"を忘れずに付けること。\n\nout_mean_df |>\n  ggplot() +\n  geom_bar(aes(x = Groups, y = Outcome), stat = \"identity\")\n\n\n\n\n図 3: ?(caption)\n\n\n\n\n　続いて、このグラフの見た目を調整してみよう。\n\nout_mean_df |>\n  ggplot() +\n  geom_bar(aes(x = Groups, y = Outcome), stat = \"identity\") +\n  # 縦軸（y軸）のラベルを変更する\n  labs(y = \"Mean(Outcome)\") +\n  # grayテーマ（デフォルトのテーマ）を使用し、フォントサイズは14\n  theme_gray(base_size = 14)\n\n\n\n\n図 4: ?(caption)\n\n\n\n\n　また、geom_label()レイヤーを足すと、棒の上にラベルを付けることもできる。ラベルに必要な情報は各ラベルの横軸上の位置（x）、縦軸上の位置（y）、ラベルの表示内容（label）だ。今回のラベルは平均値の具体的な数値を入れてみよう。\n\nout_mean_df |>\n  ggplot() +\n  geom_bar(aes(x = Groups, y = Outcome), stat = \"identity\") +\n  geom_label(aes(x = Groups, y = Outcome, label = Outcome)) +\n  labs(y = \"Mean(Outcome)\") +\n  theme_gray(base_size = 14)\n\n\n\n\n図 5: ?(caption)\n\n\n\n\n　小数点が長すぎるので3桁まで表示としよう。ここではsprintf()を使用する。使い方が簡単とは言えないが、覚える必要はなく、必要な時にググるか、本資料のコードをコピペすれば良い6。\n\nout_mean_df |>\n  ggplot() +\n  geom_bar(aes(x = Groups, y = Outcome), stat = \"identity\") +\n  # 2桁までなら %.3f を %.2f に変更\n  geom_label(aes(x = Groups, y = Outcome, label = sprintf(\"%.3f\", Outcome))) +\n  labs(y = \"Mean(Outcome)\") +\n  theme_gray(base_size = 14)\n\n\n\n\n図 6: ?(caption)\n\n\n\n\n　これで可視化ができた。ただし、以上のコードには改善の余地がある。geom_bar()とgeom_label()内のaes()関数に注目して欲しい。よく見るとxとyと同じだろう。geom_*()が共有するマッピングがあれば、ggplot()内で指定することでコードを効率化することもできる。\n\nout_mean_df |>\n  ggplot(aes(x = Groups, y = Outcome)) +\n  geom_bar(stat = \"identity\") +\n  geom_label(aes(label = sprintf(\"%.3f\", Outcome))) +\n  labs(y = \"Mean(Outcome)\") +\n  theme_gray(base_size = 14)\n\n\n\n\n図 7: ?(caption)\n\n\n\n\n\n\n統計的推定（単回帰分析）\n　これまでの作業はグループごとの応答変数の平均値であって、処置効果ではない。処置効果を計算するためには処置群の平均値から統制群の平均値を引く必要がある。たとえば、Civic Dutyはがき群の平均値は約0.317、統制群のそれは0.299であるため、Civic Dutyはがきの処置効果は約0.018である。しかし、これを各グループごとに計算することは面倒だし、何よりも得られた値が点推定値だという限界がある。得られた処置効果の不確実性は計算できない。\n　ここで有効なのが線形回帰分析である。回帰分析を行うことで処置効果の点推定値のみならず、不確実性の指標である標準誤差も計算され、区間推定や統計的仮説検定も可能となる。線形回帰分析の関数はlm()だ。第1引数としては回帰式であり、応答変数 ~ 説明変数と表記する。第2引数はdataであり、回帰式で指定した変数が入っているデータ名を指定する。回帰分析の結果は名前を付けてオブジェクトとして格納し、summary()関数を使うと、詳細が確認できる。\n\nfit1 <- lm(voted2006 ~ treatment, data = df)\n\nsummary(fit1)\n\n\nCall:\nlm(formula = voted2006 ~ treatment, data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.4206 -0.3166 -0.2985  0.6357  0.7015 \n\nCoefficients:\n                    Estimate Std. Error t value Pr(>|t|)    \n(Intercept)         0.298524   0.008864  33.680  < 2e-16 ***\ntreatmentCivic Duty 0.018085   0.021355   0.847   0.3971    \ntreatmentSelf       0.065789   0.022002   2.990   0.0028 ** \ntreatmentNeighbors  0.122037   0.022053   5.534  3.3e-08 ***\ntreatmentHawthorne  0.040637   0.021447   1.895   0.0582 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.4671 on 4995 degrees of freedom\nMultiple R-squared:  0.007123,  Adjusted R-squared:  0.006328 \nF-statistic: 8.959 on 4 and 4995 DF,  p-value: 3.312e-07\n\n\n　ちなみに、これもパイプ演算子を使うことができる。ただし、第1引数として渡すパイプ演算子の特徴上、そのまま使うことはできない。なぜならlm()関数の第1引数はデータでなく、回帰式（formula型）だから。この場合はプレースホルダー（place holder）を指定する必要がある。パイプ前のオブジェクトが入る位置を任意に指定することであり、_を使う。%>%演算子を使う場合は_でなく、.を使う。上記のコードと以下のコードは同じコードとなる。プレースホルダーは自分が使うパイプ演算子によって使い分けること。\n\nfit1 <- df |> # |> パイプを使う場合\n  lm(voted2006 ~ treatment, data = _)\n\nfit1 <- df %>% # %>% パイプを使う場合\n  lm(voted2006 ~ treatment, data = .)\n\n　Factor型、または文字型変数が説明変数の場合、自動的にダミー変数として処理され、Factor型の場合、最初の水準（ここでは\"Control\"）がベースカテゴリとなる。説明変数が文字型ならアルファベット順で最初の水準がベースカテゴリとなり、今回の例だと\"Civic Duty\"がベースカテゴリとなる。処置効果は「統制群に比べて〜」が重要となるので、数値型以外の説明変数は予めfactor化しておいた方が望ましい。\n　Civic Dutyの推定値は約0.018であり、これは統制群に比べ、Civic Duty群のvoted2006の平均値は約0.018高いことを意味する。応答変数が0、1であるため、これを割合（=投票率）で換算すると、約1.8%p高いことを意味する。つまり、Civic Dutyのはがきをもらった被験者はそうでない被験者に比べて投票率が約1.8%p高いことを意味する。他の推定値も同じやり方で解釈すれば良い。\n　それではこれらの処置効果が統計的に有意なものかを確認してみよう。統計的有意か否かを判定するためには有意と非有意の境界線が必要である、これは通常、有意水準（significance level; \\(\\alpha\\)）と呼ばれる。この有意水準は分析者が決めるものであるが、社会科学で広く使われる基準は\\(\\alpha = 0.05\\)、つまり5%だ。分析結果の画面にはPr(>|t|)列が表示されているが、これが\\(p\\)値と呼ばれるもので、これが0.05を下回る場合、統計的に有意と判定する。もし、\\(\\alpha = 0.1\\)を採用するなら、\\(p < 0.1\\)の場合において統計的に有意と判定する。Civic Dutyの\\(p\\)値は3.3e-08であり、これは\\(3.3 \\times 10^{-8}\\)を意味する。\\(10^{-1}\\)は0.1、\\(10^{-2}\\)は0.01であることを考えると非常に小さい数値であり、統計的に有意であると考えられる。また、\\(p\\)値が一定値以下であれば< 2e-16と表示される。今回の結果は、2つの処置群（SelfとNeighbors）において処置効果は統計的に有意であると判定できよう。\n　今回はサンプルサイズ34万から無作為抽出した\\(n\\)=5000のデータを使ったが、実際の論文ではいずれも統計的に有意である。なぜなら統計的有意性を判定する\\(p\\)値は処置効果の大きさ以外にも、推定値のばらつき具合（=標準誤差）の影響を受けるが、この標準誤差はサンプルサイズに反比例するからだ。ここで重要なことが分かる。それは「統計的に非有意な処置効果」は「処置効果がない」ことを意味しないことだ。たとえば、我々が日本人から男女3名ずつ抽出し、平均身長が同じだとしよう。ここから「母集団において男女の身長差はない」と解釈できるだろうか。それは全く誤りであろう。統計的に非有意な結果から分かるのは「現在のサンプル/手法/モデルにおいて男女間に身長差があるとは言えない」程度である。もう一回、男女3人ずつ抽出して比較してみれば差はあるかも知れない。また、今回はたまたま平均身長が同じだけであって、サンプルサイズが大きければ統計的に有意な差は得られるかも知れない。\n　一方、統計的に有意な差が得られたのであれば、「母集団において男女の身長差がある」と解釈できるようになる。これはもう一回、男女3人ずつ無作為抽出しても差が確認されることを意味する。むろん、100%ではない。もう一回やってみたところ、差がない可能性もある。ただし、その可能性は非常に小さく、その可能性が小さいことを、統計学では\\(p\\)値が小さいと言う。\\(p\\)値の厳密な意味は「帰無仮説が正しいと仮定した場合、今回得られた統計量と同じか、より極端な結果が得られる確率」である。身長差の例だと、帰無仮説は「男女間に身長差はない」であり、統計量とは\\(t\\)検定や単回帰分析の場合、「\\(t\\)統計量」を意味する。詳細はp値に関するアメリカ統計学会の声明や、矢内・SONG (2019)を参照すること。\n　話がややずれたが、Rの実習に戻そう。続いて、この結果を可視化してみよう。ここでも{ggplot2}パッケージを使って可視化をするが、{ggplot2}で使用可能なオブジェクトは表形式のデータである。Rコンソール上でclass(オブジェクト名)を入力すると、データのクラスが出力されるが、このクラスに\"data.frame\"があれば、{ggplot2}で使用できる。たとえば、fit1オブジェクトのクラスは\"lm\"であるため、そのまま{ggplot2}で使うことはできない。\n\nclass(fit1)\n\n[1] \"lm\"\n\n\n　推定結果を表形式に変換するためには{broom}パッケージのtidy()関数が便利だ。使い方は簡単でtidy()内に回帰分析の推定結果が格納されたオブジェクトを入れるだけである。ただし、デフォルトの設定では95%信頼区間が表示されないため、中にはconf.int = TRUEを追加しておく必要がある。\n\n# 90%信頼区間を使うのであれば conf.int = 0.9 を追加（デフォルトは0.95）\nfit1_coef <- tidy(fit1, conf.int = TRUE)\n\nfit1_coef\n\n# A tibble: 5 × 7\n  term                estimate std.error statistic   p.value conf.low conf.high\n  <chr>                  <dbl>     <dbl>     <dbl>     <dbl>    <dbl>     <dbl>\n1 (Intercept)           0.299    0.00886    33.7   2.80e-224  0.281      0.316 \n2 treatmentCivic Duty   0.0181   0.0214      0.847 3.97e-  1 -0.0238     0.0599\n3 treatmentSelf         0.0658   0.0220      2.99  2.80e-  3  0.0227     0.109 \n4 treatmentNeighbors    0.122    0.0221      5.53  3.30e-  8  0.0788     0.165 \n5 treatmentHawthorne    0.0406   0.0214      1.89  5.82e-  2 -0.00141    0.0827\n\nclass(fit1_coef)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n　fit1_coefのクラスに\"data.frame\"が含まれているので、これを使って作図することができる。\n　作図する前に、fit1_coefの加工しておきたい。それぞれの係数（estimate列）は処置効果を表しているが、切片（\"(Intercept)\"）の推定値は処置効果とは無関係である。したがって、予め切片の行を除外しておきたい。特定の行を残したり、除外する関数はfilter()である。今回はterm列の値が\"(Intercept)\"ではない行を残したいので、同値演算子（==）の否定を意味する!=演算子を使用する。\n\nfit1_coef <- fit1_coef |>\n  filter(term != \"(Intercept)\")\n\nfit1_coef\n\n# A tibble: 4 × 7\n  term                estimate std.error statistic      p.value conf.low conf.…¹\n  <chr>                  <dbl>     <dbl>     <dbl>        <dbl>    <dbl>   <dbl>\n1 treatmentCivic Duty   0.0181    0.0214     0.847 0.397        -0.0238   0.0599\n2 treatmentSelf         0.0658    0.0220     2.99  0.00280       0.0227   0.109 \n3 treatmentNeighbors    0.122     0.0221     5.53  0.0000000330  0.0788   0.165 \n4 treatmentHawthorne    0.0406    0.0214     1.89  0.0582       -0.00141  0.0827\n# … with abbreviated variable name ¹​conf.high\n\n\n　それでは作図に入ろう。処置効果を示す場合は、点推定値以外にもその不確実性を示すのは一般的である。不確実性の指標として幅広く使われるのは標準誤差（standard error; 標準偏差ではない）であるが、可視化の際にはこの標準誤差に基づき計算した信頼区間を示すのが一般的だ。有意水準が5%であれば、95%信頼区間を示し、10%なら90%信頼区間を用いる。\n　点と区間を同時に示すプロットがpoint-rangeプロットであり、{ggplot2}ではgeom_pointrange()レイヤーを使う。必要な情報はpoint-rangeの横軸上の位置（x）、点の縦軸上の位置（y）、区間の上限（ymax）と下限（ymin）である。これらの情報は全てfit1_coefに入っているため、fit1_coefをそのままggplot()関数に渡して作図することができる。\n\nfit1_coef |>\n  ggplot() +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high))\n\n\n\n\n図 8: ?(caption)\n\n\n\n\n　それでは図をカスタマイズしてみよう。図内の様々なラベルを修正するlabs()レイヤーでラベルを修正する。テーマはデフォルトのtheme_gray()の代わりに白黒テーマ（theme_bw()）を使用し、フォントサイズは12とする。また、y = 0の水平線を追加する。95%信頼区間内に0が含まれる場合、「5%水準で統計的に有意でない」と判断できる。水平線を描くにはgeom_hline()レイヤーを追加し、yintercept = 0を指定することで、0のところに水平線が描ける。\n\nfit1_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 9: ?(caption)\n\n\n\n\n　まだ気になる点がある。それは横軸の目盛りラベルにtreatmentという不要な情報がある点だ。これは作図の時点で修正することも可能だが、まずはdfのterm変数の値を修正する方法を紹介する。変数の値を修正する時にはrecode()関数を使用する。第1引数はリコーディングする変数名であり、引き続き\"元の値\" = \"新しい値\"を指定すれば良い。スペルミスに注意すること。\n\nfit1_coef <- fit1_coef |>\n  mutate(term = recode(term,\n                       \"treatmentCivic Duty\" = \"Civic Duty\",\n                       \"treatmentHawthorne\"  = \"Hawthorne\",\n                       \"treatmentNeighbors\"  = \"Neighbors\",\n                       \"treatmentSelf\"       = \"Self\"))\n\nfit1_coef\n\n# A tibble: 4 × 7\n  term       estimate std.error statistic      p.value conf.low conf.high\n  <chr>         <dbl>     <dbl>     <dbl>        <dbl>    <dbl>     <dbl>\n1 Civic Duty   0.0181    0.0214     0.847 0.397        -0.0238     0.0599\n2 Self         0.0658    0.0220     2.99  0.00280       0.0227     0.109 \n3 Neighbors    0.122     0.0221     5.53  0.0000000330  0.0788     0.165 \n4 Hawthorne    0.0406    0.0214     1.89  0.0582       -0.00141    0.0827\n\n\n　以上の作業はterm列の各値から\"treatment\"文字を\"\"に置換することなので、文字列を置換する関数であるstr_replace()を使えば、より短くすることができる。\n\nfit1_coef <- fit1_coef |>\n  mutate(term = str_replace(term, \"treatment\", \"\"))\n\n　fit1_coefも修正できたので、 図 9 と同じコードでもう一度作図してみよう。\n\nfit1_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 10: ?(caption)\n\n\n\n\n　最後に横軸の順番を修正してみよう。fit1_coefのterm列は文字型変数であるため、アルファベット順になる。これをdfのtreatment列と同様、Civic Duty、Self、Neighbors、Hawthorneの順にしたい。この場合fit1_coefのterm列をfactor化すれば良い。factor()関数を使っても良いが、ここではまた便利な技を紹介しよう。それはfct_inorder()関数だ。これは表示されている順番をfactorの順番とする関数だ。実際、fit1_coefの中身を見ると、表示順番はCivic Duty、Self、Neighbors、Hawthorneだ。非常に嬉しい状況なので、fct_inorder()を使ってみよう。\n\nfit1_coef <- fit1_coef |>\n  mutate(term = fct_inorder(term))\n\nfit1_coef\n\n# A tibble: 4 × 7\n  term       estimate std.error statistic      p.value conf.low conf.high\n  <fct>         <dbl>     <dbl>     <dbl>        <dbl>    <dbl>     <dbl>\n1 Civic Duty   0.0181    0.0214     0.847 0.397        -0.0238     0.0599\n2 Self         0.0658    0.0220     2.99  0.00280       0.0227     0.109 \n3 Neighbors    0.122     0.0221     5.53  0.0000000330  0.0788     0.165 \n4 Hawthorne    0.0406    0.0214     1.89  0.0582       -0.00141    0.0827\n\n\n　それでは、 図 10 と同じコードでもう一度作図してみよう。\n\nfit1_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 11: ?(caption)\n\n\n\n\n　これで処置効果の可視化もバッチリだ。\n\n\n多重比較の問題\n　グループが2つ、つまり統制群と統制群のみが存在する場合、我々が比較を行う回数は1回のみである（統制群 - 処置群）。しかし、今回のデータの場合、処置群は4つである。これは比較を4回行うことを意味する。具体的には「統制群 - 処置群1」、「統制群 - 処置群2」、「統制群 - 処置群3」、「統制群 - 処置群4」だ。比較を繰り返すほど、統計的に有意な結果が得られる可能性は高い。極端な話、1000回程度検定を繰り返せば、本当は効果がなくてもたまたま統計的に有意な結果が何回かは得られるだろう。これが多重検定（multiple testing）の問題である。したがって、比較の回数が多くなるにつれ、統計的有意性検定にも何らかのペナルティーを課す必要がある。\n　多重比較におけるペナルティーの付け方はいくつかあるが、ここでは最も保守的な（=研究者にとって都合の悪い）補正法であるボンフェローニ補正（Bonferroni correction）を紹介する。これは非常に単純で、\\(p\\)値や信頼区間を計算する際、「統計的有意」と判定されるハードルを上げる方法である。予め決めておいた有意水準（\\(\\alpha\\)）が0.05で、比較の回数が4回であれば、\\(p\\)値が\\(0.05 \\times \\frac{1}{4} = 0.0125\\)を下回る場合において「5%水準で有意である」と判定する。信頼区間でいえば通常の95%信頼区間（1 - 0.05）でなく、98.75%信頼区間（1 - 0.0125）を使うこととなる。この結果、統計的に有意な結果が得られたら「1.25%水準で〜」と解釈するのではなく、「5%水準で〜」と解釈する必要がある。\n　95%以外の信頼区間を求めるのは簡単で、tidy()関数内にconf.levelを修正すれば良い。指定されていない場合はデフォルトで0.95が割り当てられているが、これを0.9875と修正する。\n\nfit1_coef <- tidy(fit1, conf.int = TRUE, conf.level = 0.9875)\n\nfit1_coef\n\n# A tibble: 5 × 7\n  term                estimate std.error statistic   p.value conf.low conf.high\n  <chr>                  <dbl>     <dbl>     <dbl>     <dbl>    <dbl>     <dbl>\n1 (Intercept)           0.299    0.00886    33.7   2.80e-224   0.276     0.321 \n2 treatmentCivic Duty   0.0181   0.0214      0.847 3.97e-  1  -0.0353    0.0714\n3 treatmentSelf         0.0658   0.0220      2.99  2.80e-  3   0.0108    0.121 \n4 treatmentNeighbors    0.122    0.0221      5.53  3.30e-  8   0.0669    0.177 \n5 treatmentHawthorne    0.0406   0.0214      1.89  5.82e-  2  -0.0130    0.0942\n\n\n　それでは 図 11 と同じ図を作ってみよう。まず、切片の行を除外するが、ここではfilter()を使わず、slice()の使った方法を紹介する。slice()は()内に指定した行を残す関数だ。たとえば、slice(fit1_coef, 2)ならfit1_coefの2行目のみを残す。fit1_coefはslice()の第1引数だから、パイプ演算子を使うことも可能で、こちらの方を推奨する。そうすれば()内には残す行のみの指定で済む。slice(2)のみなら2行目を残し、slice(1, 3, 5)なら1、3、5行目を残す。:を使うと「〜行目から〜行目まで」の指定ができる。処置効果の係数はfit1_coefの2行目から5行目までなので、2:5と指定すれば良い。\n\nfit1_coef <- fit1_coef |>\n  slice(2:5)\n\nfit1_coef\n\n# A tibble: 4 × 7\n  term                estimate std.error statistic      p.value conf.low conf.…¹\n  <chr>                  <dbl>     <dbl>     <dbl>        <dbl>    <dbl>   <dbl>\n1 treatmentCivic Duty   0.0181    0.0214     0.847 0.397         -0.0353  0.0714\n2 treatmentSelf         0.0658    0.0220     2.99  0.00280        0.0108  0.121 \n3 treatmentNeighbors    0.122     0.0221     5.53  0.0000000330   0.0669  0.177 \n4 treatmentHawthorne    0.0406    0.0214     1.89  0.0582        -0.0130  0.0942\n# … with abbreviated variable name ¹​conf.high\n\n\n　続いて、term変数の値から\"treatment\"の文字を除去し、fit1_coefでの出力順番でtermをfactor化する。\n\nfit1_coef <- fit1_coef |>\n  mutate(term = recode(term,\n                       \"treatmentCivic Duty\" = \"Civic Duty\",\n                       \"treatmentHawthorne\"  = \"Hawthorne\",\n                       \"treatmentNeighbors\"  = \"Neighbors\",\n                       \"treatmentSelf\"       = \"Self\"),\n         term = fct_inorder(term))\n\nfit1_coef\n\n# A tibble: 4 × 7\n  term       estimate std.error statistic      p.value conf.low conf.high\n  <fct>         <dbl>     <dbl>     <dbl>        <dbl>    <dbl>     <dbl>\n1 Civic Duty   0.0181    0.0214     0.847 0.397         -0.0353    0.0714\n2 Self         0.0658    0.0220     2.99  0.00280        0.0108    0.121 \n3 Neighbors    0.122     0.0221     5.53  0.0000000330   0.0669    0.177 \n4 Hawthorne    0.0406    0.0214     1.89  0.0582        -0.0130    0.0942\n\n\n　最後に 図 11 と同じコードで作図する。\n\nfit1_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high)) +\n  labs(x = \"Treatments\", \n       y = \"Average Treatment Effects (w/ 98.75% CI)\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 12: ?(caption)\n\n\n\n\n\n\n統計的推定（重回帰分析）\n　今回の例は無作為割当が成功しており、処置前変数の偏りは見られない。しかし、何らかの理由で処置前変数の偏りが生じる場合がある。その「何らかの理由」が応答変数にまで影響を与えるのであれば、それは交絡変数（confounder）となり、バイアスの原因となる。この場合、偏りが生じている処置前変数を統制（control）することによってバイアスを小さくすることができる。今回は不要であるが、性別や誕生年などの共変量を統制した推定をしてみよう。\n　やり方は簡単で、lm()内の回帰式を応答変数 ~ 説明変数1 + 説明変数2 + ...のように説明変数を+で足していけば良い。\n\nfit2 <-lm(voted2006 ~ treatment + female + yob + hh_size +\n            voted2000 + voted2002 + voted2004, data = df)\n\nsummary(fit2)\n\n\nCall:\nlm(formula = voted2006 ~ treatment + female + yob + hh_size + \n    voted2000 + voted2002 + voted2004, data = df)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.7573 -0.3447 -0.1953  0.5184  0.9506 \n\nCoefficients:\n                      Estimate Std. Error t value Pr(>|t|)    \n(Intercept)          6.0886118  0.9164461   6.644 3.39e-11 ***\ntreatmentCivic Duty  0.0307108  0.0205474   1.495 0.135074    \ntreatmentSelf        0.0703356  0.0211562   3.325 0.000892 ***\ntreatmentNeighbors   0.1147107  0.0212088   5.409 6.65e-08 ***\ntreatmentHawthorne   0.0423327  0.0206241   2.053 0.040165 *  \nfemale              -0.0240666  0.0127276  -1.891 0.058696 .  \nyob                 -0.0030326  0.0004705  -6.445 1.27e-10 ***\nhh_size              0.0025215  0.0085056   0.296 0.766896    \nvoted2000            0.0666981  0.0147950   4.508 6.69e-06 ***\nvoted2002            0.1644528  0.0133278  12.339  < 2e-16 ***\nvoted2004            0.1583835  0.0130339  12.152  < 2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.449 on 4989 degrees of freedom\nMultiple R-squared:  0.08363,   Adjusted R-squared:  0.0818 \nF-statistic: 45.53 on 10 and 4989 DF,  p-value: < 2.2e-16\n\n\n　{modelsummary}パッケージのmodelsummary()関数を使えば、推定結果がより見やすくなる。\n\nmodelsummary(fit2)\n\n\n\n \n  \n      \n    Model 1 \n  \n \n\n  \n    (Intercept) \n    6.089 \n  \n  \n     \n    (0.916) \n  \n  \n    treatmentCivic Duty \n    0.031 \n  \n  \n     \n    (0.021) \n  \n  \n    treatmentSelf \n    0.070 \n  \n  \n     \n    (0.021) \n  \n  \n    treatmentNeighbors \n    0.115 \n  \n  \n     \n    (0.021) \n  \n  \n    treatmentHawthorne \n    0.042 \n  \n  \n     \n    (0.021) \n  \n  \n    female \n    −0.024 \n  \n  \n     \n    (0.013) \n  \n  \n    yob \n    −0.003 \n  \n  \n     \n    (0.000) \n  \n  \n    hh_size \n    0.003 \n  \n  \n     \n    (0.009) \n  \n  \n    voted2000 \n    0.067 \n  \n  \n     \n    (0.015) \n  \n  \n    voted2002 \n    0.164 \n  \n  \n     \n    (0.013) \n  \n  \n    voted2004 \n    0.158 \n  \n  \n     \n    (0.013) \n  \n  \n    Num.Obs. \n    5000 \n  \n  \n    R2 \n    0.084 \n  \n  \n    R2 Adj. \n    0.082 \n  \n  \n    AIC \n    6195.0 \n  \n  \n    BIC \n    6273.2 \n  \n  \n    Log.Lik. \n    −3085.506 \n  \n  \n    F \n    45.533 \n  \n  \n    RMSE \n    0.45 \n  \n\n\n\n\n\n　また、複数のモデルをlist()関数でまとめると、モデル間比較もできる。\n\nmodelsummary(list(\"w/o Covariates\" = fit1, \"w/ Covariates\" = fit2))\n\n\n\n \n  \n      \n    w/o Covariates \n    w/ Covariates \n  \n \n\n  \n    (Intercept) \n    0.299 \n    6.089 \n  \n  \n     \n    (0.009) \n    (0.916) \n  \n  \n    treatmentCivic Duty \n    0.018 \n    0.031 \n  \n  \n     \n    (0.021) \n    (0.021) \n  \n  \n    treatmentSelf \n    0.066 \n    0.070 \n  \n  \n     \n    (0.022) \n    (0.021) \n  \n  \n    treatmentNeighbors \n    0.122 \n    0.115 \n  \n  \n     \n    (0.022) \n    (0.021) \n  \n  \n    treatmentHawthorne \n    0.041 \n    0.042 \n  \n  \n     \n    (0.021) \n    (0.021) \n  \n  \n    female \n     \n    −0.024 \n  \n  \n     \n     \n    (0.013) \n  \n  \n    yob \n     \n    −0.003 \n  \n  \n     \n     \n    (0.000) \n  \n  \n    hh_size \n     \n    0.003 \n  \n  \n     \n     \n    (0.009) \n  \n  \n    voted2000 \n     \n    0.067 \n  \n  \n     \n     \n    (0.015) \n  \n  \n    voted2002 \n     \n    0.164 \n  \n  \n     \n     \n    (0.013) \n  \n  \n    voted2004 \n     \n    0.158 \n  \n  \n     \n     \n    (0.013) \n  \n  \n    Num.Obs. \n    5000 \n    5000 \n  \n  \n    R2 \n    0.007 \n    0.084 \n  \n  \n    R2 Adj. \n    0.006 \n    0.082 \n  \n  \n    AIC \n    6584.0 \n    6195.0 \n  \n  \n    BIC \n    6623.1 \n    6273.2 \n  \n  \n    Log.Lik. \n    −3285.982 \n    −3085.506 \n  \n  \n    F \n    8.959 \n    45.533 \n  \n  \n    RMSE \n    0.47 \n    0.45 \n  \n\n\n\n\n\n　modelsummary()は推定値と標準誤差（カッコ内）が別々の行として出力する。これを一行でまとめるためには、以下のようにコードを修正する。\n\nmodelsummary(list(\"w/o Covariates\" = fit1, \"w/ Covariates\" = fit2),\n             estimate  = \"{estimate} ({std.error})\",\n             statistic = NULL)\n\n\n\n \n  \n      \n    w/o Covariates \n    w/ Covariates \n  \n \n\n  \n    (Intercept) \n    0.299 (0.009) \n    6.089 (0.916) \n  \n  \n    treatmentCivic Duty \n    0.018 (0.021) \n    0.031 (0.021) \n  \n  \n    treatmentSelf \n    0.066 (0.022) \n    0.070 (0.021) \n  \n  \n    treatmentNeighbors \n    0.122 (0.022) \n    0.115 (0.021) \n  \n  \n    treatmentHawthorne \n    0.041 (0.021) \n    0.042 (0.021) \n  \n  \n    female \n     \n    −0.024 (0.013) \n  \n  \n    yob \n     \n    −0.003 (0.000) \n  \n  \n    hh_size \n     \n    0.003 (0.009) \n  \n  \n    voted2000 \n     \n    0.067 (0.015) \n  \n  \n    voted2002 \n     \n    0.164 (0.013) \n  \n  \n    voted2004 \n     \n    0.158 (0.013) \n  \n  \n    Num.Obs. \n    5000 \n    5000 \n  \n  \n    R2 \n    0.007 \n    0.084 \n  \n  \n    R2 Adj. \n    0.006 \n    0.082 \n  \n  \n    AIC \n    6584.0 \n    6195.0 \n  \n  \n    BIC \n    6623.1 \n    6273.2 \n  \n  \n    Log.Lik. \n    −3285.982 \n    −3085.506 \n  \n  \n    F \n    8.959 \n    45.533 \n  \n  \n    RMSE \n    0.47 \n    0.45 \n  \n\n\n\n\n\n　また、alignで各列を左寄せや右寄せに（文字列は左寄せ、数値は右寄せが一般的）、coef_rename引数で表示される変数名を変更することもできる。\n\nmodelsummary(list(\"w/o Covariates\" = fit1, \"w/ Covariates\" = fit2),\n             estimate  = \"{estimate} ({std.error})\",\n             statistic = NULL,\n             align = \"lrr\", # 1列は左寄せ、2列は右寄せ、3列は右寄せ\n             coef_rename = c(\"treatmentCivic Duty\" = \"Civic Duty\",\n                             \"treatmentSelf\"       = \"Self\",\n                             \"treatmentNeighbors\"  = \"Neighbors\",\n                             \"treatmentHawthorne\"  = \"Hawthorne\",\n                             \"female\"              = \"Female\",\n                             \"yob\"                 = \"Year of Birth\",\n                             \"hh_size\"             = \"Household Size\",\n                             \"voted2000\"           = \"Voted (2000)\",\n                             \"voted2002\"           = \"Voted (2002)\",\n                             \"voted2004\"           = \"Voted (2004)\"))\n\n\n\n \n  \n      \n    w/o Covariates \n    w/ Covariates \n  \n \n\n  \n    (Intercept) \n    0.299 (0.009) \n    6.089 (0.916) \n  \n  \n    Civic Duty \n    0.018 (0.021) \n    0.031 (0.021) \n  \n  \n    Self \n    0.066 (0.022) \n    0.070 (0.021) \n  \n  \n    Neighbors \n    0.122 (0.022) \n    0.115 (0.021) \n  \n  \n    Hawthorne \n    0.041 (0.021) \n    0.042 (0.021) \n  \n  \n    Female \n     \n    −0.024 (0.013) \n  \n  \n    Year of Birth \n     \n    −0.003 (0.000) \n  \n  \n    Household Size \n     \n    0.003 (0.009) \n  \n  \n    Voted (2000) \n     \n    0.067 (0.015) \n  \n  \n    Voted (2002) \n     \n    0.164 (0.013) \n  \n  \n    Voted (2004) \n     \n    0.158 (0.013) \n  \n  \n    Num.Obs. \n    5000 \n    5000 \n  \n  \n    R2 \n    0.007 \n    0.084 \n  \n  \n    R2 Adj. \n    0.006 \n    0.082 \n  \n  \n    AIC \n    6584.0 \n    6195.0 \n  \n  \n    BIC \n    6623.1 \n    6273.2 \n  \n  \n    Log.Lik. \n    −3285.982 \n    −3085.506 \n  \n  \n    F \n    8.959 \n    45.533 \n  \n  \n    RMSE \n    0.47 \n    0.45 \n  \n\n\n\n\n\n　処置効果に注目すると、共変量の有無が推定結果に影響をほぼ与えないことが分かる。これは無作為割当に成功したことを意味する。"
  },
  {
    "objectID": "material/day04.html#番外編",
    "href": "material/day04.html#番外編",
    "title": "Rの復習",
    "section": "番外編",
    "text": "番外編\n　modelsummary()を使えば、複数のモデルの推定結果を一つの表としてまとめられる。しかし、図の場合はどうだろう。共変量なしモデルとありモデルを 図 12 のように一つにまとめることはできるだろうか。もちろん出来る。\n　まず、重回帰分析を行った結果（fit2）から処置効果の推定値情報を抽出し、fit1_coefと同じ構造のデータとしてまとめる。\n\nfit2_coef <- tidy(fit2, conf.int = TRUE, conf.level = 0.9875)\n\nfit2_coef <- fit2_coef |>\n  slice(2:5) |>\n  mutate(term = recode(term,\n                       \"treatmentCivic Duty\" = \"Civic Duty\",\n                       \"treatmentHawthorne\"  = \"Hawthorne\",\n                       \"treatmentNeighbors\"  = \"Neighbors\",\n                       \"treatmentSelf\"       = \"Self\"),\n         term = fct_inorder(term))\n\nfit2_coef\n\n# A tibble: 4 × 7\n  term       estimate std.error statistic      p.value conf.low conf.high\n  <fct>         <dbl>     <dbl>     <dbl>        <dbl>    <dbl>     <dbl>\n1 Civic Duty   0.0307    0.0205      1.49 0.135        -0.0206     0.0821\n2 Self         0.0703    0.0212      3.32 0.000892      0.0175     0.123 \n3 Neighbors    0.115     0.0212      5.41 0.0000000665  0.0617     0.168 \n4 Hawthorne    0.0423    0.0206      2.05 0.0402       -0.00920    0.0939\n\n\n　処置効果の推定値や標準誤差などが異なるが、構造としては同じである。続いて、bind_rows()を用い、この2つのデータを一つの表として結合する。2つの表はlist()関数でまとめるが、それぞれ\"モデル名\" = データ名と指定する。最後に、.id = \"Model\"を追加する。\n\nbind_rows(list(\"Model 1\" = fit1_coef, \n               \"Model 2\" = fit2_coef),\n          .id = \"Model\")\n\n# A tibble: 8 × 8\n  Model   term       estimate std.error statistic      p.value conf.low conf.h…¹\n  <chr>   <fct>         <dbl>     <dbl>     <dbl>        <dbl>    <dbl>    <dbl>\n1 Model 1 Civic Duty   0.0181    0.0214     0.847 0.397        -0.0353    0.0714\n2 Model 1 Self         0.0658    0.0220     2.99  0.00280       0.0108    0.121 \n3 Model 1 Neighbors    0.122     0.0221     5.53  0.0000000330  0.0669    0.177 \n4 Model 1 Hawthorne    0.0406    0.0214     1.89  0.0582       -0.0130    0.0942\n5 Model 2 Civic Duty   0.0307    0.0205     1.49  0.135        -0.0206    0.0821\n6 Model 2 Self         0.0703    0.0212     3.32  0.000892      0.0175    0.123 \n7 Model 2 Neighbors    0.115     0.0212     5.41  0.0000000665  0.0617    0.168 \n8 Model 2 Hawthorne    0.0423    0.0206     2.05  0.0402       -0.00920   0.0939\n# … with abbreviated variable name ¹​conf.high\n\n\n　2つの表が1つとなり、Modelという列が追加される（これは.idで指定した名前）。そして、fit1_coefだった行は\"Model 1\"、fit2_coefだった行は\"Model 2\"が付く。ただし、これだけだと表が結合されて出力されるだけなので、fit_coefという名のオブジェクトとして作業環境内に格納しておく。\n\nfit_coef <- bind_rows(list(\"Model 1\" = fit1_coef, \n                           \"Model 2\" = fit2_coef),\n                      .id = \"Model\")\n\n　それではfit_coefを使って、作図をしてみよう。コードは 図 12 と同じであるが、facet_wrap()レイヤーを追加する。これはグラフのファセット（facet）分割を意味し、ファセットとは「面」を意味する。()内には~分割の基準となる変数名を入れる。2つのモデルがあり、fit_coefだとModel列がどのモデルの推定値かを示している。\n\nfit_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  facet_wrap(~ Model) +\n  theme_bw(base_size = 12)\n\n\n\n\n図 13: ?(caption)\n\n\n\n\n　今回の結果だとモデル1もモデル2も推定値がほぼ同じである。ファセット分割の場合、小さい差の比較が難しいというデメリットがある。この場合、ファセット分割をせず、一つのファセットにpoint-rangeの色分けした方が読みやすくなる。point-rangeをModelの値に応じて色分けする場合、aes()内にcolor = Modelを追加する。\n\nfit_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high,\n                      color = Model)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 14: ?(caption)\n\n\n\n\n　何かおかしい。point-rangeの横軸上の位置が同じということから重なってしまい、モデル1のpoint-rangeがよく見えない。これをずらすためにaes()の外側にposition = position_dodge2(1/2)を追加する。\n\nfit_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high,\n                      color = Model),\n                  position = position_dodge2(1/2)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  theme_bw(base_size = 12)\n\n\n\n\n図 15: ?(caption)\n\n\n\n\n　これで図は完成だが、少し修正してみよう。{ggplot2}の場合、凡例は右側に表示されるが、これを下側へ移動させるためにはtheme()レイヤーを追加し、legend.position = \"bottom\"を指定する。また、モデル1とモデル2が具体的に何を意味するのかを明確に示したい。これはfit_coefのModel列を修正しても良いが、今回はscale_color_discrete()レイヤーで修正する例を紹介する。\n\nfit_coef |>\n  ggplot() +\n  geom_hline(yintercept = 0) +\n  geom_pointrange(aes(x = term, y = estimate,\n                      ymin = conf.low, ymax = conf.high,\n                      color = Model),\n                  position = position_dodge2(1/2)) +\n  labs(x = \"Treatments\", y = \"Average Treatment Effects\") +\n  scale_color_discrete(labels = c(\"Model 1\" = \"w/o Covariates\",\n                                  \"Model 2\" = \"w/ Covariates\")) +\n  theme_bw(base_size = 12) +\n  theme(legend.position = \"bottom\")\n\n\n\n\n図 16: ?(caption)"
  },
  {
    "objectID": "material/day02.html",
    "href": "material/day02.html",
    "title": "因果推論の考え方",
    "section": "",
    "text": "新しいタブで開く"
  },
  {
    "objectID": "material/day03.html",
    "href": "material/day03.html",
    "title": "無作為化比較試験",
    "section": "",
    "text": "新しいタブで開く"
  },
  {
    "objectID": "material/day01.html",
    "href": "material/day01.html",
    "title": "ガイダンス",
    "section": "",
    "text": "新しいタブで開く"
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "実習用データ集",
    "section": "",
    "text": "ファイル名\n備考\n\n\n\n\n1\nxxx.csv\nXXX"
  }
]